Meine Ablage
1. Introduction
- buildin commando -> implemented directly in shell
- alias gohome="cd ~"
- who -> which user is logged it (you      tty1         Jan 30 11:14)
- whoami
- ps -f -> current process list. PPID=Parent PID. bash scripts (or here 'ps') are executed in an additional bash -> PPID(7742) = PID(3672)
  UID        PID  PPID  C STIME TTY          TIME CMD
  you       3672  3658  0 Jan20 pts/38   00:00:00 /bin/bash
  you       7742  3672  0 03:03 pts/38   00:00:00 ps -f
- ps PID
    PID TTY      STAT   TIME COMMAND
  63138 pts/6    Ss     0:00 /bin/bash

- scrip finduser -> find / -user you -print 2>/dev/null
- $! -> contains PID of last started background process
- $$ - > own PID
- #!/bin/bash -> She-Bang line
- ./script or bash script -> executes script in a subshell -> e.g. useful to avoid changing environment variables
- source ./script == . ./script (point + space) -> executes scipt in current bash
- Debuggen: enable debugging #!/bin/bash -x or set -x or bash -x script. disable debugging set +x
 - before each script line is executed, it is printed after '+' (actually after $PS4)
 - e.g ps -ef | wc -l -> +ps -ef \n +wc -l 
 - export PS4='[--- LINE: $LINENO ---] ' -> this will print line number when debugging a script
 - $LINENO, die nach der Ausführung immer durch die entsprechende Zeilennummer ersetzt wird.
- Redirection:
 - command > file -> same as command 1> file -> redirect standard stream to file
 - command 2> file -> redirect standard error  stream to file
 - command > file 2>&1 -> redirect both streams to file
 - command >> file -> append to file
 - input redirection: grep audio < find_tot.dat
 - command | tee file -> redirect to standard output AND to file
- Piping cmd1 | cmd 2: connecting standard output of one cmd1 to the standard input of cmd2
- du -c: prints size of directory and its sub directories
- Wildcards (filename expansion): * ? []
 -  [ab] [a-z] datei[12][a] datei[!12] datei[[:digit:]].txt
    [:alnum:]	Buchstaben, Unterstrich und dezimale Ziffern
    [:alpha:]	Groß- und Kleinbuchstaben
    [:digit:]	Dezimale Ziffern
    [:lower:]	Kleinbuchstaben
    [:upper:]	Großbuchstaben
    [:print:]	Nur druckbare Zeichen
    [:space:]	Leerzeichen, Tabulator ...
 - prefix{ muster1, muster2 }suffix -> prefixmuster1suffix prefixmuster2suffix
  - touch datei{orginal{.bak,.txt},kopie{.bak,.txt}} -> dateikopie.bak  dateikopie.txt  dateiorginal.bak  dateiorginal.txt
  - ls datei*{.bak,.txt} -> dateikopie.bak  dateikopie.txt  dateiorginal.bak  dateiorginal.txt
  
- Muster alternatives:
 - shopt [-pqsu] [-o] [optname ...] -> Set and unset shell options.
 - shopt –s extglob: ls @(prozess|promess|process|propan).dat; ls !(prozess|promess|process|propan).dat
 @(pattern1 | patter2 | ... | patternN)	Eines der Muster
 !(pattern1 | patter2 | ... | patternN)	Keines der Muster
 +(pattern1 | patter2 | ... | patternN)	Mindestens eines der Muster
 ?(pattern1 | patter2 | ... | patternN)	Keines oder eines der Muster
 *(pattern1 | patter2 | ... | patternN)	Keines, eines oder mehrere Muster
 - Tilde-Expansion: ~ home folder, ~USER home folder of USER, ~- previsited folder, ~+ same as pwd -> echo ~ ~- ~+ -> /home/qahmad /home/qahmad /home/qahmad/scripts

2. Variables
- Variable-Interpolation: datum=$(date +%Y_%m_%d); mkdir backup_$datum
- undefined variables -> empty string. Use option -u to catch show warning about undefined variables
 - sh -u ./aerror -> ./aerror: line 10: var3: unbound variable
- varialbes should be used with {} in order to avoid problems:
 - file=back_; cp datei.txt $filedatei.txt -> datei.txt copied into ".txt" because there is no variable $filedatei.txt
 - file=back_; cp datei.txt ${file}datei.txt -> datei.txt copied into "back_datei.txt"
- delete variables: unset variable-name
- Constants using readonly: readonly x=5; x=6 -> bash: x: readonly variable
 - Bei der Verwendung von readonly handelt es sich um eine Zuweisung! Daher erfolgt auch das Setzen des Schreibschutzes ohne das Zeichen $.
- Integer Arithmetik (UNIX-Befehl expr) -> expr 5 + 4 (must be separated by ' ')
 - preceed * with \: expr 2 \* 2 -> 4
 - command substitution using `` (Gravis character): z=`expr $x + $y` -> store result in z
- Integer Arithmetik (Bash and Korn Shell only)
 - ((z=5+5)) or z=$((5+5)) -> z=10: '((' tells the shell that an arethmetik expression follows
 - bash only z=$[5+5]
 - let z=x+y (builtin command) equivalent to z=$((x+y))
 - Arithmetic Operators: + - * / % (modulo) << >> & ^ | += -= *= /= %= <<= >>=  &= ^= |=
 - typeset or declate: set or declyre variable type
  - typeset -i a b c; a=1; b=2; c=a+b (without $ symbol); d=\(a+b\)*c
- Floating Point Arithmetik with bc (UNIX command)
 - Variable=`echo "[scale=n ;] Rechenoperation" | bc [-l]`
 - bc -l -> use mathematic library funcs s(x) c(x) a(x) l(x) e(x) / sin cos atan log e^
 - bc expects lines of arithmetic expressions from stdin and outputs result lines into stdout
- Convert Numbers with bc: bin/hex/dec
 - ibase/obase: input/output base -> any number between 2 and 16
  - dez=`echo "obase=10 ; ibase=2 ; 1111011" | bc` -> 123
- Strings:
 - cut -c5 gedicht.txt: cut only the 5th character of each line - cut 
 -c5-10; -c5-; -c1,3,5,6,7–12 - cut -d\; -f1,3 datei.csv: -d for 
 delimiter   -f for field -> cut the first and the third columns - 
 paste: opposite of cut - paste -d\; namen.txt nummer.txt > 
 zusammen.txt -> Qassem;+97246... - tr - translate or delete characters 
 - tr von_Zeichen nach_Zeichen - tr a b < gedicht.txt: replace all 
 occurrences of a by b - cut -d\; -f1,3 datei.csv | tr \; '\t' -> 
 tot;17:32------->tot     17:32 (replace ; by tabulator) - tr '[a-z]' 
 '[A-Z]' < gedicht.txt -> ranges must be included in '' to avoid file 
 expansion by the shell - tr -d ' ','\n' < gedicht.txt -> delete all 
 spaces and newlines - tr -s ' ' ' ' < datei.txt: -s --squeeze-repeats 
 replaces all sequances of ' ' by a ' ': "Q.   Abu   Ahmad" -> "Q. Abu 
 Ahmad" - awk: laenge=`echo $zeichen | awk '{print length($zeichen)}'` 
 -> assign value by command substitution using `` - Awks 
 Builtin-Stringfunktionen
	Funktion				Bedeutung
	tolower str				Komplette Zeichenkette in Kleinbuchstaben
	toupper str				Komplette Zeichenkette in Großbuchstaben
	index(str, substr)		Gibt die Position zurück, wo substr in str anfängt
	match(str, regexpr)		Überprüft, ob der reguläre Ausdruck regexpr in str enthalten ist
	substr(str, start, len)	Gibt einen Teilstring ab Postion start mit der Länge len aus str zurück.
	split(str, array, sep)	Teilt einen String in einzelne Felder auf und gibt diese an ein Array. sep dient dabei als Feldtrenner.
	gsub(alt, neu, str)		Ersetzt in str den String alt durch neu
	sub(alt, neu, str)		Ersetzt erstes Vorkommen von alt durch neu in str
	sprintf("fmt",expr)		Verwendet die printf-Formatbeschreibung für expr
- Extended String Funktions for Bash and Korn Shells
 - $(#zeichenkette): String-Length
 - x="./home/you/Dokuments/shell/kapitel2.txt"
 - ${var#pattern}:  find shortest match from left and return var without matched pattern: echo ${x#*/} -> home/you/Dokuments/shell/kapitel2.txt
 - ${var##pattern}: find longest match from left and return var without matched pattern:  echo ${x##*/} -> kapitel2.txt
 - ${var%pattern}:  find shortest match from right and return var without matched pattern: echo ${x%/*} -> ./home/you/Dokuments/shell
 - ${var%%pattern}: find longest match from right and return var without matched pattern: echo ${x%%/*} -> .
 - String rechts oder links abschneiden (Korn-Shell only)
  - typeset -L5 str; str=1234567890 -> 12345
  - typeset -R3 str; str=1234567890 -> 890
 - (Teil-)Strings ausschneiden (Bash only)
  - ${var:start:length} or ${var:start}: str=1234567890; echo ${str:3:6} -> 456789; echo ${str:5} -> 67890
- Quoting and Command-Substitution
	'	Single Quote, einfaches Anführungszeichen
	"	Double Quote, doppeltes Anführungszeichen (oder Gänsefüßchen)
	`	Back Quote, Backtick, Gravis-Zeichen, umgekehrtes einfaches Anführungszeichen
 - Hinweis   Wie bei einer Pipe, geht auch bei einer Kommando-Substitution die Fehlermeldung verloren.
 - Die Verwendung von $(...) gegenüber `...` hat natürlich nur einen rein optischen Vorteil. Die Form $(...) lässt sich erheblich einfacher lesen, aber wem nützt das was, wenn es die Bourne-Shell nicht kennt. Wer sich sicher sein kann, dass seine Scripts auch immer in einer Bash oder einer Korn-Shell ausgeführt werden, der kann sich frohen Herzens damit anfreunden. Damit fällt wenigstens bei der Quoterei die Back Quote weg, und Sie müssen nur noch die Single und Double Quotes beachten.
- Arrays (Bash and Korn-Shell only)
 - Assigning by: a[x]=value; Accessing by: ${a[x]}
 - it would be better to declare a variable as an array: typeset –ir array
 - initializing:
  - Bash-Shell
   - no limits to array size
   - a=(null eins zwei drei vier fuenf ...)
   - a=([2]=zwei drei) -> a[0] and a[1] would unset a then initializes a
  - Korn-Shell
   - set -A array null eins zwei drei vier fuenf
   - limit to array size: 512, 1024 oder maximal 4096
 - ${array[*]} or ${array[@]} would print the whole array (space separated)
 - ${#array[*]} or ${#array[@]}: array size
 - delete an array or an element: unset array; unsert array[2]
 - array_kopie=(${array_quelle[*]}) (bash) or set -A array_kopie ${array_quelle[*]} (Korn)
  - Achtung: Hierbei gibt es noch eine üble Stolperfalle. So löscht man beispielsweise in der Bash array[1] mit unset und kopiert dann das array, so steht in array_kopie[1] der Inhalt von array[2].
 - x=(Muhammad Rashid Qassem Samih); echo ${x[0]:0:3} ; echo ${x[*]:1:3} -> Muh\nRashid Qassem Samih
- Export Variables: sometimes there is a need to share a variable among multiple scripts -> export variable
 - export variable=1234; export var1 var2 var3 var4
 - scripts are executed in a subshell. all exported variables are copied by value, that is, subshells cannot modify variables of the parent shell
 - The POINT-COMMAND: Executing scripts in the current shell: ". ./script" or "source ./script"
  - main usage: reloading of config files: . ./bashrc
  - Es gibt außerdem noch zwei Anwendungsfälle, wo bei einem Script die benutzerdefinierten Variablen ohne einem Export sichtbar sind. Dies geschieht durch die Verwendung von Kommando-Substitution `...` und bei einer Gruppierung von Befehlen (...). In beiden Fällen bekommt die Subshell (bzw. das Shellscript) eine komplette Kopie aller Variablen der Eltern-Shell kopiert.
  - automatic export: typeset -x var=value -> x is exported automatically in subshells
  - automatic export is stopped by: typeset +x var
  - 'declare' is a synonym to 'typeset'
  - typing typeset or declare alone with print all the exported variables
- Environment Variables: Wenn Sie ein Script, eine neue Shell oder ein Programm starten, so wird diesem Programm eine Liste von Zeichenketten (genauer Array von Zeichenketten) übergeben. Diese Liste wird als Umgebung des Prozesses bezeichnet. Gewöhnlich enthält eine solche Umgebung zeilenweise Einträge in Form von: variable=wert
  Somit sind Umgebungsvariablen zunächst nichts anderes als global mit dem Kommando export oder typeset –x definierte Variablen.
- Automatic Shell-Variables: 
 - $0 script name: für Fehlermeldungen verwendet, zum Beispiel um anzuzeigen, wie man ein Script richtig anwendet bzw. aufruft
 - $$: PID of the current shell
 - $?: last exit code
 - $!: PID of last process started in background
 - $1 bis $n	Argumente aus der Kommandozeile
 - $*	Alle Argumente aus der Kommandozeile in einer Zeichenkette
 - $@	Alle Argumente aus der Kommandozeile als einzelne Zeichenketten (Array von Zeichenketten)
 - $#	Anzahl aller Argumente in der Kommandozeile
 - $_	(Bash only) Letztes Argument in der Kommandozeile des zuletzt aufgerufenen Kommandos
 - $RANDOM: random number between 0 and 32767 -> RANDOM=1; echo $RANDOM -> 17767
 - LINENO	Diese Variable enthält immer die aktuelle Zeilennummer im Shellscript. Wird die Variable innerhalb einer Scriptfunktion aufgerufen, entspricht der Wert von LINENO den bis zum Aufruf innerhalb der Funktion ausgeführten einfachen Kommandos. Außerhalb von Shellscripts ist diese Variable nicht sinnvoll belegt. Wird die LINENO-Shell-Variable mit unset gelöscht, kann sie nicht wieder mit ihrer automatischen Funktion erzeugt werden.
 - OLDPWD	Der Wert ist das zuvor besuchte Arbeitsverzeichnis; wird vom Kommando cd gesetzt.
 - OPTARG	Der Wert ist das Argument der zuletzt von getopts ausgewerteten Option.
 - OPTIND	Enthält die Nummer (Index) der zuletzt von getopts ausgewerteten Option
 - PPID	Prozess-ID des Elternprozesses (Parent Process ID = PPID); eine Subshell, die als Kopie einer Shell erzeugt wird, setzt PPID nicht.
 - PWD	Aktuelles Arbeitsverzeichnis
 - RANDOM	Pseudo-Zufallszahl zwischen 0 bis 32767; weisen Sie RANDOM einen neuen Wert zu, so führt dies dazu, dass der Zufallsgenerator neu initialisiert wird.
 - REPLY	Wird vom Shell-Kommando read gesetzt, wenn keine andere Variable als Rückgabeparameter benannt ist und bei Menüs (select) enthält REPLY die ausgewählte Nummer.
 - SECONDS	Enthält die Anzahl von Sekunden, die seit dem Start (Login) der aktuellen Shell vergangen ist. Wird SECONDS ein Wert zugewiesen, erhöht sich dieser Wert jede Sekunde automatisch um eins.
 - ERRNO	Fehlernummer des letzten fehlgeschlagenen Systemaufrufs
 - BASH	Kompletter Pfadname der aktuellen Shell
 - BASH_VERSION	Versionsnummer der Shell
 - EUID	Beinhaltet die effektive Benutzerkennung des Anwenders. Diese Nummer wird während der Ausführung von Programmen, bei denen das SUID-Bit aktiviert ist, gesetzt.
 - HISTCMD	Enthält die Nummer des aktuellen Kommandos aus der Historydatei
 - HOSTTYPE	Typ des Rechners. Für Linux kommen u. a. die Typen i386 oder i486 in Frage.
 - OSTYPE	Name des Betriebssystems. Da allerdings die Variable OSTYPE den aktuellen Wert zum Übersetzungszeitpunkt der Bash anzeigt, ist dieser Wert nicht zuverlässig. Re-kompilieren Sie bspw. alles neu, ändert sich dieser Wert nicht mehr. Zuverlässiger ist da wohl das Kommando uname.
 - PROMPT_COMMAND	Hier kann ein Kommando angegeben werden, das vor jeder Eingabeaufforderung automatisch ausgeführt wird.
 - SHLVL	Steht für den Shell-Level. Bei jedem Aufruf einer neuen Shell in der Shell wird der Shell-Level um eins erhöht; der Wert 2 kann z. B. innerhalb eines Scripts bestehen, das aus einer Login-Shell gestartet wurde. Eine Möglichkeit, zwischen den Levels zu wechseln, gibt es nicht.
 - UID	Die User-ID des Anwenders. Diese Kennung ist in der Datei /etc/passwd dem Benutzernamen zugeordnet.
- Parameter and Arguments
 - ls -l file: arguments are 'l' and 'file'
 - CLI-Parameter (also called Position-Parameters) $1 bis $9. $0 contains the command name. The Shalee-Variable $IFS
 - i.e. IFS="," -> script_file arg1,arg2,arg3...
 - $*	Alle Argumente aus der Kommandozeile in einer Zeichenkette
  - for i in $*; do echo i done:
    - if $*=eine variable Anzahl von Argumenten -> 5 arguments are printed
    - if $*="eine variable Anzahl von Argumenten" -> 1 argument but the for loop would print 5 lines, because for uses IFS=" " to separate between tokens
    - for i in "$*" -> would see one argument and would print only one line
 - $@	Alle Argumente aus der Kommandozeile als einzelne Zeichenketten (Array von Zeichenketten)
 - Merke   Alle Argumente (auch mehr als 9) sind durch $* oder $@ erreichbar. $* liefert sie als ein Wort, verkettet mit Leerzeichen, und $@ liefert sie als ein Argument pro Wort.
 - $#	Anzahl aller Argumente in der Kommandozeile
 - shift [n]: $1...$n; shift -> $2=$1 $3=$2 ...$n-1=$n $#=$#-1
 - ./script Jürgen von Braunschweig 30 -> there are 4 arguments
 - ./script Jürgen "von Braunschweig" 30 -> there are 3 arguments
 - If there is more than 9 arguments, then the are accessed as followed: ${n}, e.g. echo ${99}
 - set arguments $1...$n: set arg1 arg2 ... argn -> $1...$n are set (IFS must contain at least one space)
 - set -- -a -b -c -> use -- in order to set -arg into $1...n variable
 - set --: unsets all position arguments (Korn/Bash). Other Shells use: set ""
 - example: IFS=" "; set `who | grep qahmad'
 -                   set `date`; echo "$3.$2.$6 um $4"
 - getopts: Evaluating CLI Options -> getopts Options Variable [Arguments]
  - Options must be before filenames
  - learn by example
	while getopts abc:D: opt 2>/dev/null # 2>/dev/null to supress error generated by getopts. c: and D: -> Options c and D expects an argument
	do
	   case $opt in
		   a) echo "Option a";;
		   b) echo "Option b";;
		   c) echo "Option c : ($OPTARG)";; # OPTARG contains argument for option c
		   D) echo "Option D : ($OPTARG)";;
		   ?) echo "($0): Ein Fehler bei der Optionsangabe" # if ?) not found -> getopts outputs an error and exit with error code (e.g. missing argument or unknown option)
	   esac
	done
  - OPTIND: contains option index. it is initialized by one and is increased by one for each call of getopts
            Wenn eine Kommandozeile mehrfach eingelesen werden soll, muss der Index manuell zurückgesetzt werden.
  - getopts:
   - return 0: Option found
   - return error code:
    - end of arguments reached, or
    - error found:
     - to supress error messages:
      - ':' must be first in getopts options, i.e. 	while getopts :abc:D:, or
      - OPTERR=0
 - Defaults for Variables
  - directory=${1:-`pwd`}; ls -ld $directory | grep ^d -> if $1 is missing, set directoy to pwd
 ${var:–wort}	return var.size() ? var : wort
 ${var:+wort}	return var.size() ? wort : null
 ${var:=wort}	return var.size() ? var : (var = wort && return var)
 ${var:?wort}	if(var.size()) return var; else{ echo "bash: xx: " (wort.size() ? wort : "parameter null or not set") }
 NULL = Variable is unset or is ""
4. Control Structures:
- if [ bedingung ]; then befehl(e); elif [ bedingun ]; then... else befehl(e) fi # OR
 if [ bedingung ]
then
   # Ja, Bedingung war erfolgreich
   # ... hier Befehle für erfolgreiche Bedingung verwenden
else
...
fi
- Example: if grep "^$1" /etc/passwd > /dev/null 2>&1; then .... fi # OR
- grep "^$1" /etc/passwd > /dev/null
  if [ $? -ne 0 ]; then ... fi
- Command chaining via pipes with if:
 - @? -> result of last command in the chain
 - e.g.: if ls -l /usr/include | grep $1 | wc -l -> $?==0, even if $1 is Null or pattern not found
- Evaluating PIPESTATUS (Bash only)
 - PIPESTATUS is an array and contains the exit codes of the last executed commands (${PIPESTATUS[0]}...${PIPESTATUS[n]})
 - 
- The Command test:
 - if test Ausdruck <-> if [ Ausdruck ] (symbolic form of test)
 - there MUST BE a space after each expresion. [ 1 -lt 2 ] or test 1 -lt 2.
 - Integer comparison: var1 -eq -ne -lt -gt -le -ge var2
 - Integer comparison with let command (Bash and Korn-Shell only):
  - let z=x+y; ((z=x+y))
  - if (( $a > $b )) or if let "$a > $b"
 - String Comparison: [ "$var1" = "$var2" ] [ "$var1" != "$var2" ] [ –z "$var" ] [ –n "$var" ]
  - We should include each variable in double quotes in order to avoid errors when $var does not exist or var consists of multiple tokes (separated by ' ')
 - String Comparison (Bash and Korn-Shell only):
  - [[ "$var1" == "$var2" ]] [[ "$var1" != "$var2" ]] [[ –z "$var" ]] [[ –n "$var" ]] [[ "$var1" > "$var2" ]] [[ "$var1" < "$var2" ]]
    [[ "$var" ==/!= pattern ]] -> pattern must be on the right side and must not include double quotes
                                  pattern might include *, ? und [ ]. E.g. if [[ "$1" = *ist* ]]
 - Status of files: if [ -Operator Datei ]
-Operatoren zum Testen des Dateityps 
	–b DATEI	Datei existiert und ist ein block special device (Gerätedatei).
	–c DATEI	Datei existiert und ist ein character special file (Gerätedatei).
	–d DATEI	Datei existiert und ist ein Verzeichnis.
	–f DATEI	Datei existiert und ist eine reguläre Datei.
	–h DATEI	Datei existiert und ist ein symbolischer Link (dasselbe wie –L).
	–L DATEI	Datei existiert und ist ein symbolischer Link (dasselbe wie –h).
	–p DATEI	Datei existiert und ist eine named Pipe.
	–S DATEI	Datei existiert und ist ein (UNIX-Domain-)Socket (Gerätedatei im Netzwerk).
	–t [FD] 	Ein Filedescriptor (FD) ist auf einem seriellen Terminal geöffnet.
- Operatoren zum Testen der Zugriffsrechte auf eine Datei
	–g DATEI	Datei existiert und das setgid-Bit ist gesetzt.
	–k DATEI	Datei existiert und das sticky-Bit ist gesetzt.
	–r DATEI	Datei existiert und ist lesbar.
	–u DATEI	Datei existiert und das setuid-Bit ist gesetzt.
	–w DATEI	Datei existiert und ist beschreibbar.
	–x DATEI	Datei existiert und ist ausführbar.
	–O DATEI	Datei existiert und der Benutzer des Scripts ist der Eigentümer (owner) der Datei.
	–G DATEI	Datei existiert und der Benutzer des Scripts hat dieselbe GID wie die Datei.
- Operatoren zum Testen von charakteristischen Eigenschaften
	–e DATEI	Datei existiert.
	–s DATEI	Datei existiert und ist nicht leer.
	DATEI1 –ef DATEI2	Datei1 und Datei2 haben dieselbe Geräte- und Inodennummer und sind somit Hardlinks.
	DATEI1 –nt DATEI2	Datei1 ist neueren Datums (Modifikationsdatum, nt = newer time) als Datei2.
	DATEI1 –ot DATEI2	Datei1 ist älter (Modifikationsdatum, ot = older time) als Datei2. 
- Logical Operators
 - Bash and Korn-Shell only: && || !
 - All: [ expr1 -a expr2 ] [ expr1 -o expr2 ] [ ! expr ]
 - Example: if [ -f $file -a -w $file ] <-> if [ -f $file ] && [ -w $file ]
            number=${1:-"5"}; if [ $number -gt 0 -a $number -lt 11 ] or if (( $number > 0 )) && (( $number < 11 ))
            if (( $number == 1 )) || (( $number == 2 )) <-> if [ $number -eq 1 -o $number -eq 2 ]
            if [ $answer = "j" -o $answer = "ja" ] <-> if [[ $answer == "n" ]] || [[ $answer == "nein" ]]
 - Klammerung muss außerhalb von [[ ]] stattfinden: if ([[ $var1 == "abc" ]] && [[ $var2 == "cde" ]]) || ( [[ $var3 == "abc" ]] )           
 - # Innerhalb von eckigen Klammern müssen runde Klammern ausgeschaltet werden: if [ \( "$var1" = "abc" -a  "$var2" = "cde" \)  -o "$var3" = "abc" ]
 - # Bash und Korn-Shell: if (( $var1 == 4 )) || ( (( $var2 == 2 )) && (( $var3 == 3 )) )
   # alle Shells: if [ $var1 -eq 4 -o \( $var2 -eq 2 -a $var3 -eq 3 \) ]
 - Verwendung von Klammern bei Ausdrücken
	Ausdruck für	Ohne Klammern	Klammerung	Shell
	Zeichenketten	[[ Ausdruck ]]	([[ Ausdruck ]])	Bash und Korn
	Zeichenketten	[ Ausdruck ]	[ \( Ausdruck \) ]	alle Shells
	Zahlenwerte	(( Ausdruck ))	( (( Ausdruck )) )	Bash und Korn
	Zahlenwerte	[ Ausdruck ]	[ \( Ausdruck \) ]	alle Shells
	Dateitest	[ Ausdruck ]	[ \( Ausdruck \) ]	alle Shells
	Dateitest	[[ Ausdruck ]]	([[ Ausdruck ]])	nur Korn
- Short Circuit-Tests: using && || with commands:
 - cmd1 && cmd2: execute cmd2 iff cmd1 succeeds
 - cmd1 || cmd2: execute cmd2 iff cm1 fails
- case:
case "$var" in
   muster1)   kommando		# or (muster1) -> Dies verhindert, dass bei Verwendung von case in einer Kommando-Substitution ein Syntaxfehler auftritt
              ...			# muster might include *, ? oder [ ]. Ebenso können Sie eine Muster-Alternative wie *(...|...|...); @(...|...|...)
              kommando ;; 	# ;; := break -> if does not exists it continues to muster2 and if matches muster2 -> execute muster2.commands...
   muster2)   kommando
              ...
              kommando ;;
   mustern)   kommando
              ...
              kommando ;;
   *)         default action
esac
 - examples:
  - Mo)   echo "Mo : Backup Datenbank machen" ;;
  - Mo|Mon)   echo "Mo : Backup Datenbank machen" ;;
  - [jJ])
  - [jJ][aA])
  - [jJ]|[jJ][aA])
  - case with options
   - -[tT]|-test)
   - -[hH]|-help|-hilfe)
   - while getopts tThH opt 2>/dev/null; do case $opt in t|T) echo "Option test";; h|H) echo "Option hilfe";; ?) echo "($0): Ein Fehler bei der Optionsangabe"...
4.9 Loops
- for var in liste_von_parameter; do kommandos...; done
- for x in 1 2 3 9; do echo "x=$x"; done
- Process argeuments with for: for datei in "$@"; do...; done <-> for datei; do...; done
 - Lassen Sie den Zusatz in "$@" weg, setzt die for-Schleife diesen automatisch ein -> for datei; do...; done
- For and filename substitution: for file in *; for file in *.txt *.c log[1-9].txt; for file in * .*; 
- handle failed muster-resolving ->
	for datei in *.jpg
	do
	   case "$datei" in # this is not a switch statement -> it handles failing muster resolving (*.jpg)
		  *.jpg)   echo "Keine Datei zum Muster *.jpg vorhanden" ;;
		  *)       echo $datei ;;
	   esac
	done
- For and Arrays (Bash and Korn-Shell only): array=( 1 2 3 4 5 6 7 8 9 ); for value in ${array[*]}
- For and Counters (Bash only Ab Version 2.0.4): for (( var=Anfangswert ; Bedingung ; Zähler /*i++ or i-- or ((i+=x)) or ((i-=x))*/ )); do...done
- example:
	array=( $* )
	for((i=0; i<$#; i++)); do echo "Argument $i ist ${array[$i]}"; done
	for((i=5; i>0; i--)); do echo $i; sleep 1; done
	for((i=100; i>0; ((i=i/2)) )); do echo $i; done
- while loop: [bedingung or command]; do.....done -> while [ $i -lt $# ]  or  while [ "$input" != "ende" ]
- until loop: opposite of while -> execute as long as condition is false
 - while [ ! "$input" = "ende" ] <-> until [ "$input" = "ende" ]
- control jumps: continue; break; exit; -> analog to c++
5. Terminal-In- and Output
- Terminal: at first unix time there was only one PCs. Multiple terminals (screens) were connected to the same PC.
 - A proccess called getty (in linux called mingetty) waits for a terminal to connect and authenticate -> then it opens a session
 - Session := The time after authentication until exit
 - Nowadays there are Terminal-Emulators -> are programms which pretend to be a real terminal
 - Virtual-Terminals: CTRL+ALT+F1...CTRL+ALT+F7
 - ps -e | grep getty -> (...3092 tty1     00:00:00 getty...). if e.g. tty3 is not in the list -> then some user is logged in tty3. when the user logs out -> a getty process will then start on tty3
 - Pseudo-Terminal (pts or ttyp under unix) -> the commay tty tells you in which pseudo terminal you are logged in (e.g /dev/pts/4 or /dev/ttyp1)
 - ls -l /dev/pts -> crw--w----  1 tot tty 136, 37 2005–03–01 22:46 37
- 5.2) Outputs
 - echo [-option] argument1 argument2 ... argument_n -> prints argument1...n + new line
 - echo -n arguments <-> echo -e "arguments\c": does not print newline 
 - echo -e: activate interpretation of escape sequencies
 - Escape Sequencies: \a Alarm-Ton (Beep); \b Backspace; ein Zeichen zurück; \c continue; das Newline-Zeichen unterdrücken; \f	Form Feed; einige Zeilen weiterspringen
   \n Newline; Zeilenumbruch; \r return; zurück zum Anfang der Zeile; \t Tabulator (horizontal); \v Tabulator (vertikal); meistens eine Zeile vorwärts
   \\ das Backslash-Zeichen ausgeben; \0nnn	ASCII-Zeichen in oktaler Form (nur sh und ksh); z. B. aus \0102 wird B (dezimal 66)
   \nnn	ASCII-Zeichen in oktaler Form (nur Bash); z. B. aus \102 wird wird B (dezimal 66)
 - printf format argument1 argument2 ... argument_n
 - printf "Kunde: %-10s Anzahl: %-5d Gegenstand: %15s\n" $1 $2 $3 -> %-10s allign $1 to left ; %15s allign $3 to the right -> "Kunde: J.Wolf     Anzahl: 10    Gegenstand:          Socken"
	text=Kopfstand
	a=3
	b=12345
	printf "|01234567890123456789|\n"
	printf "|%s|\n" $text
	printf "|%20s|\n" $text
	printf "|%-20s|\n" $text
	printf "|%20.4s|\n" $text
	printf "|%-20.4s|\n\n" $text
	printf "Fließkommazahl: %f\n" $a
	printf "gekürzt       : %.2f\n" $a
	printf "Ganzzahl      : %d\n" $b
	printf "gekürzt       : %.2d\n" $b
	printf "erweitert     : %.8d\n" $b
	Das Script bei der Ausführung:

	|01234567890123456789|
	|Kopfstand|
	|           Kopfstand|
	|Kopfstand           |
	|                Kopf|
	|Kopf                |
	Fließkommazahl: 3,000000
	gekürzt       : 3,00
	Ganzzahl      : 12345
	gekürzt       : 12345
	erweitert     : 00012345
- tput for terminal control:
 - tput is a program (not builtin) and knows the terminal libraty terminfo (previously /etc/termcap). It contains many attributes for controlling the terminal
 - tput clear | tr '\033' 'X' ; echo -> X[HX[2J (\033 replaced by X)
 - echo -en '\033[H\033[2J' -> clears the screen -> works only for echo $TERM = xterm*
 - tput cols -> #columns; tput lines -> #lines; tput colors -> #colors supported by terminal; tput pairs -> color pairs
 - tput {bold, boldoff, blink, rev (inverse font), smul (underline), rmul (underline off), sgr0 (reload defaults)}
  - echo "Text wird `tput bold``tput rev``tput smul`Hervorgehoben`tput sgr0`"
  - echo "`tput setaf 2``tput setab 5`QASSEM" -> set background and forderground colors (argument 0..7)
  - tput clear -> clear screen; tput home -> move cursor to (0,0); tput cup n m; move cursor to (n,m)
  - tput dl1/il1 -> delete current line/add a new line at current line; tput dch1 -> delete one character at current position
- xxd: make a hexdump or do the reverse: echo ABCD | xxd -> "00000000: 4142 4344 0a                             ABCD."
- od: dump files in octal and other formats:
 - echo ABCD | od -> 0000000 041101 042103 000012
 - echo ABCD | od -c -> 0000000   A   B   C   D  \n
 - echo ABCD | od -x -> 0000000 4241 4443 (alignment?)
- 5.2) Inputs
 - read variable: store standard input (keyboard until pressing ENTER) into variable
 - read a b -> 'Qassem Abu\t\t Ahmad' -> a=Qassem  b=Abu Ahmad -> whitespaces replaced by one space
 - read -option variable: 
  - -n number, e.g. read -n 5 x -> QASSE -> x=QASSE -> no need to press enter to exit command -> after reading n-th char it will exit automatically
  - -s: silent -> dont show what is beeing typed, e.g. for passwords
  - -t s: wait s seconds for input. after a timeout the read commands returns error=1 and the script continue execution
 - read variable < zitat.txt: reading one line from file and store it in variable
 - WARNING: while read var < datei; -> this will always read the same line
  - Solution:
   - while read line; do ... done < datei, or
   - cat datei | while read line; do ... done -> nach jedem erneuten Schleifendurchlauf die Pipe geschlossen und die Variable somit verworfen wird
 - Heredoc (Here Document): command substitution is done
Command <<TEXT_MARKE
Heute ist `date`
TEXT_MARKE
 - Backslash before TEXT_MARKE or 'TEST_MARKE' will prevent command substitution, i.e. exactly Heute ist `date` is inserted to command's stdin
Command <<\TEXT_MARKE
Heute ist `date`
TEXT_MARKE
 - setting variable using heredoc
count=`cat <<TEXT_MARKE
\`ls -l | wc -l\`
TEXT_MARKE`
 - "<<- TEXT_MARKE" should remove leading TABs (not spaces). Thid did not work in my tests 
 - heredoc and read:
while read line; do...done <<TEXT_MARKE
line1
...
line_n
TEXT_MARKE
- The Variable IFS (Internal Field Separator):
 - echo -n "$IFS" | xxd -> 00000000: 2009 0a; 20 space; 09 tab; 0a newline
 - echo -n "$IFS" | od -c -> 0000000      \t  \n
 - BACKIFS="$IFS"; IFS=\; echo -n "$IFS" | od -c -> 0000000; read nachname vorname alter (input=Wolf;Jürgen;30)
 - IFS=: ; set $PATH; for path in "$@"; do echo "$path" done; IFS=$BACKIFS <-> echo $PATH | tr ':' '\n'
- read and Arrays (Bash and Korn-Shell only):
 - typeset -i i=0; while [ $i -lt 5 ]; do printf "Eingabe machen : "; read valarr[$i]; i=i+1; done -> for i < 5 -> echo ${valarr[$i]}
 - typeset -i i=0; while read vararray[$i]; do i=i+1; done < datei_zum_einlesen
- read string and store tokens in an array (depending on IFS)
read -a array <<TEXTMARKE
$variable
TEXTMARKE
- read -p "Ihr Vorname : " vorname (only bash)  <-> read name?"Ihr Name bitte: " (only Korn)
- Default-Variable for read: if no variable given to read -> stroe input in $REPLY
- Reading n characters (only Bash?): read -n 1 var -> presseing one char will store it in var and exit
- Reading n characters using dd:
# Terminal in den "rohen" Modus schalten, weil Terminal zeilengepuffert ist
stty raw -echo
# In Schleife überprüfen, ob 'q' gedrückt wurde
while [ "$char" != "q" ]
do
   char=`dd bs=1 count=1 2>/dev/null`
done
# Den "rohen" Modus wieder abschalten
stty -raw echo
- examples for dd (data duplicator https://linuxconfig.org/learning-linux-commands-dd):
 - dd if=$input_data of=$output_data [options] (https://linuxconfig.org/learning-linux-commands-dd)
  - dd if=/dev/urandom of=/dev/sda bs=4k: Fills the drive with random data
  - dd if=/dev/sda of=/dev/sdb bs=4096: Drive-to-drive duplication
  - dd if=/dev/zero of=/dev/sda bs=4k: Clean up a hard drive (may need to be repeated)
  - dd if=inputfile of=/dev/st0 bs=32k conv=sync: Copy from file to tape device
  - dd if=/dev/st0 of=outfile bs=32k conv=sync: The above, reversed
  - dd if=/dev/sda | hexdump -C | grep [^00]: Check if drive is really zeroed out
  - dd if=/dev/urandom of=/home/$user/hugefile bs=4096: Fills out a partition (careful with system partitions!)
  - ls -l myfile -> -rw-r--r-- 6703104 Oct 31 18:25 myfile -> dd if=/dev/urandom of=myfile bs=6703104 count=1: Scramble a file (maybe before deleting it)
- Catching ESCAPE-SEQUENCIES
 - Some buttons like ARROWN and Fn consists of a sequence of chars starting with \E (ESC=ASCII-27). This sequence might have variable lenth depending on terminal type and encoding
 - TERMINAL-ESCAPE-SEQUENCIES using infocmp -> ...cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,...
  - man 5 terminfo | grep cuu1 -> "cursor_up                 cuu1   up   up one line"
  - ARROW_UP=\E[A = ESC + [A
  - C\C++: if(read(STDIN_FILENO, &c, 1) > 0) if(c == 27) if(strcmp(buffer,"[A") == SUCCESS) -> ARROW_UP clicked
- Reading Passwords:
 - stty -echo; read password; stty echo -> turn off/on output
- 5.4) Redirection using exec: exec > file; exec >> file; exec 2> file; exec 2>> file; exec < file
 - echo "$0 wird ausgeführt" (output on screen); exec >ausgabe.txt (redirect all outputs to ausgabe.txt); val=`ls -l | wc -l`; echo "Im Verzeichnis $HOME befinden sich $val Dateien"; echo "Hier der Inhalt: "; ls -l
 - exec <data.dat; printf "%-15s %-15s %-8s\n" "Nachname" "Vorname" "Telefon"; printf "+%-15s+%-15s+%-8s\n" "--------" "-------" "-------"
   while read vorname nachname telefon; do printf " %-15s  %-15s  %-8d\n" $nachname $vorname $telefon; done
   - each loop will read 3 new tokens
- 5.5) File Descriptors (fd): an integer refering to an openned file. fds 0 stdin, 1 stdout, 2 stderr -> connected with the terminal tty
 -  echo example > file <=> echo example 1> file : redirect stdout to file
 - read x < file <=> read x 0< file : redirect stdin to file
 - echo "Hallo Welt auf stderr" >&2 <=> echo "Hallo Welt auf stderr" 1>&2 : redirect stdout to stderr
 - command <&fd : read from file or file descriptor
 - command >&fd : write to file or file descriptor
 - command >>&fd : append to file or file descriptor
 - User Defined File Descriptors (only from 3 until 9):
  - exec fd> destination; exec fd>> destination; exec fd< destination; releasing by exec fd>&-
  - exec 3> `tty`; echo "Hallo neuer Kanal" >&3; exec 3>&-; echo "Hallo neuer Kanal" >&3 -> bash: 3: Ungültiger Dateideskriptor
 - User-Defined fds are also usable in subshells
 - Using exec >&- without channel will close stdout. the same applies for fds 0 and 2
   REOPENING: exec 1> `tty`
 - Useful Applications:
  - read/write access posiotion is kept after each operation:
   - who > user.dat; read user1 <user.dat; read user2 <user.dat -> user2 contains the same line as user1 because the read access points always at the beginning
   - who > user.dat; exec 3< user.dat; read user1 <user.dat; read user2 <user.dat -> user1 contains line1 and user2 contains line2
  - Reading from multiple files:
   - exec 3< file1; exec 4< file2; exec 5< file3; exec 6< file4; while true; do read var1 <&3; do read var2 <&4; do read var3 <&5; do read var4 <&6; done
  - Reading from stdin and from a file:
   - exec 3< $1; while read line <&3; do echo $line; printf "Eine weitere Zeile einlesen? [j/n] : "; read; [ "$REPLY" = "n" ] && break; done
 - 5.5.2) Redirection with [n]<> file
  - open file for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.
  - exec 3<> $1; while read line <&3; do echo $line; printf "Hier eine neue Zeile einfügen? [j/n] : "; read; [ "$REPLY" = "j" ] && break; done; printf "Bitte hier die neue Zeile eingeben : "; read; echo $REPLY >&3 -> Des Ruhmes Würdigkeit verliert an Wert,\nHier eine neue Zeile\nder selbst mit Lob sich ehrt.
- 5.6) Named Pipes: 
 - rarely used. same as normal pipe but it can be accessed be multiple processes
 - eine Konstruktion,welche die Ausgabe eines Prozesses als Eingabe zur Verfügung stellt. Bei normalen Pipes mussten die Prozesse vom selben Elternprozess abstammen (um an die Dateideskriptoren heranzukommen)
 - created by: mknod name p   or   mkfifo name -> e.g. mknod apipe p    prw-r--r--  1 tot users 0 2005–03–07 06:10 apipe (type p for named pipe)
   echo "Hallo User" > apipe; wait blockingly until data is read from another process. open o new terminal and type: tail -f apipe -> Hallo User
  - Prozess1, der in die Pipe schreibt, kann erst dann weiterarbeiten, wenn Prozess2 aus dieser Pipe liest, also ein weiterer Prozess die Leseseite einer Pipe öffnet (liest immer alles auf einmal)
 - name pipe file exists until it is deleted (exactly as normal files)
 - don't forget to adjust file permission if a different user should access the named pipe
 - Im Unterschied zu einer normalen Pipe, die in einem Schritt erzeugt wird (ein Inode-Eintrag, zwei Datei-Objekte und die Speicherseite) und sofort zum Lesen und Schreiben bereitsteht, werden die Named Pipes von den Prozessen im Userspace geöffnet und geschlossen. Dabei beachtet der Kernel, dass eine Pipe zum Lesen geöffnet ist, bevor etwas hineingeschrieben wird, sowie dass eine Pipe zum Schreiben geöffnet ist, bevor sie auch zum Lesen geöffnet wurde. Auf der Kernelebene ist dies in etwa dasselbe wie beim Erzeugen einer Gerätedatei (Device File).
 - echo a > apipe; in second terminal echo b > apipe; in third terminal cat apipe would print a\nb\n
 - after writing in (echo) or reading from (read) a named pipe, it will be directly closed. to write multiple lines ar to read linewise use loops:
  - while true; do echo 1; echo 2; echo 3; break; done > apipe
    i=1; while read line; do echo "line $i: $line"; i=$((i+1)); done < apipe
- 6.7) Menus with select (bash and korn shell only)
 - select variable in menu_points; do cmd1;...cmdn; done -> produces a numbered list of menu points. the user selects a number and the corresponding point is stored in variable. The corresponding number is stored in $REPLY. If user selects an invalid point -> variable="". After each selections all commands between do and done are executed. Then the user is asked to select again a number (endless loop exited by a exit/break or CTRL+D=EOF). PS3 is used as a prompt (usually is #). menu_points misht expads, i.e. b< using *-, ?, [], ``...
 - PS3="Ihre Wahl : "; select auswahl in Punkt1 Punkt2 Punkt3 Punkt4 Ende; do case "$auswahl" in
      Ende)  echo "Ende"; break ;;
        "")  echo "Ungültige Auswahl" ;;
         *)  echo "Sie haben $auswahl gewählt"
   esac
done
 - examples: select var in *.c *.sh *.txt; select var in `who | cut -c1–8 | grep -v $LOGNAME`; select var in `ls a*`
 -  PS3="Datei zum Editieren auswählen : " # Ein neues Auswahl-Prompt
    EDIT=vi # Hier den Editor Ihrer Wahl angeben
    select auswahl in * Ende; do
       case "$auswahl" in
          Ende)  echo "Ende" ; break ;;
            "")  echo "$REPLY: Ungültige Auswahl" ;;
             *)  [ -d "$auswahl" ] && \
                 echo "Verzeichnis kann nicht editiert werden" &&\
                 continue
                 $EDIT $auswahl
                 break ;;
       esac
    done 
 - Sub-Menus: in case statement write another select satement: A)  select auswahla in A1 A2 A3; do...
- 5.8) dialog und Xdialog (have same format, just replace dialog with xdialog. xdialog has mor features)
 - dialog --yesno [Text] [height] [width]: (height or width = 0 -> auto determined)
  - dialog --yesno "Möchten Sie wirklich abbrechen?" 0 0; antwort=$? (0=ja, 1=no); clear
 - [X]dialog --msgbox [Text] [Höhe] [Breite]: shows informational box
  - dialog --msgbox "Die Antwort war JA." 5 40
 - [X]dialog --infobox [Text] [Höhe] [Breite]: dialog --infobox "Dieser Vorgang kann ein wenig dauern" 5 50
 - [X]dialog --inputbox [Text] [Höhe] [Breite] [[Vorgabetext]]
  - name=`dialog --inputbox "Wie heißen Sie?" 0 0 "Jürgen" 3>&1 1>&2 2>&3`; dialog --clear; dialog --msgbox "Hallo $name, Willkommen bei $HOST!" 5 50; clear
  - 3>&1 1>&2 2>&3 -> Nachteil von dialog: Ergebnis wird hier immer auf die stderr statt auf die stdout erfolgt. Und um die Dialogausgabe zur weiteren Verarbeitung in eine Variable zu schreiben, müssen Sie ebenso vorgehen.
  - to understand --clear option see example:
   - dialog --begin 2 2 --yesno "" 0 0 --and-widget --begin 4 4 --yesno "" 0 0 --and-widget --begin 6 6 --yesno "" 0 0
     (Only the last widget is left visible)
     dialog --clear       --begin 2 2 --yesno "" 0 0 --and-widget --clear       --begin 4 4 --yesno "" 0 0 --and-widget --begin 6 6 --yesno "" 0 0
 - dialog --textbox "$0 (filename)" 0 0 -> shows $0 in a text box. we an scroll to all directions
 - [X]dialog --menu [Text] [Höhe] [Breite] [Menühöhe] [Tag1] [Eintrag1] ...
   os=`dialog --menu "Betriebssystem wählen" 0 0 0 "Linux" "" "BSD" "" "Solaris" "" 3>&1 1>&2 2>&3`; echo $os -> select from a menu
 - [X]dialog --checklist [Text] [Höhe] [Breite] [Listenhöhe] [Tag1] [Eintrag1] [Status1] ...: select multiple tags
   pizza=`dialog --checklist "Pizza mit ..." 0 0 4 Käse "" on Salami "" off Schinken "" off Thunfisch "" off 3>&1 1>&2 2>&3`; echo $pizza
   -> e.g pizza = "Käse Thunfisch"
 - [X]dialog --radiolist [Text] [Höhe] [Breite] [Listenhöhe] [Tag1] [Eintrag1] [Status1] ... -> select only one tag
   pizza=`dialog --radiolist "Pizza mit ..." 0 0 3 Salami "" off Schinken "" off Thunfisch "" off 3>&1 1>&2 2>&3`; echo $pizza
 - [X]dialog --gauge [Text] [Höhe] [Breite] [Prozent]
   (echo 10; sleep 1; echo 20; sleep 1; echo 30; sleep 1; echo 40; sleep 1; echo 50; sleep 1; echo "XXX"; echo "WE REACHED 100%") | dialog --title "Fortschrittszustand" --gauge "Starte Backup-Script" 8 30 10
  - gauge expect more info from stdin -> INT -> Percentage; echo "XXX" instructs gauge that a new text is coming
 - Verändern von Aussehen und Ausgabe: Aussehen und die Ausgabe beeinflussen:
  --title:	Eine Titelzeile für einen Dialog festlegen (Beschriftung für den oberen Rand)
  --backtitle:	Eine Titelzeile am Bildschirmrand festlegen (hierbei wird häufig der Scriptname verwendet, der zum jeweiligen Dialog gehört)
  --clear:	Dialog-Bildschirm löschen
- 5.9) Visualization of measurement data 2D and 3D. Examples in http://gnuplot.sourceforge.net/demo/ 
 - plot [x_min:x_max] [y_min:y_max] sin(x),cos(x),tan(x),x**2
 - Variables and Parameters: see 'help set' -> The `set` command can be used to set _lots_ of options.  No screen is drawn, however, until a `plot`, `splot`, or `replot` command is given.
 - set xlabel "X-ACHSE"; set ylabel "Y-ACHSE"; set xrange [0:4]; set yrange [-1:1]; plot sin(x)
 - Output Redirection: 'set terminal' shows all supported terminals
  - set output file.endung; set terminal png/postscript/latex/windows(x11)/PRN(printer, note that terminal must be set with the correct driver); plot sin(x) -> output saved into file.endung
  - '! bash-command': executes a bash command without exiting gnuplot
  - Variables: var=value; print var -> var_a=1+var*sqrt(2); print var_a
   - Pi=3.1415; set xrange [-2*Pi:2*Pi]; a=0.6; plot a*sin(x)
   - Defining Functions: func(x)=var*sin(x); var=0.5; plot func(x); var=0.6; plot func(x)
 - 5.9.7) Interpretation of data from files:
    - set xrange [0:60]; set yrange [0:40]; set xlabel "Monat"; set ylabel "Grad/Celcius"; set style data lp; set title "Temperatur-Daten 1999-2002"; plot "messdat.dat" using 1:2 t "1999", "messdat.dat" using 1:3 t "2000", "messdat.dat" using 1:4 t "2001", "messdat.dat" using 1:5 t "2002"
      using 1:2 -> use first  column for X-Achse and second column for Y-Achse
 - 5.9.8) replot:
  - instead of giving the previous settings again after changing the file data (columns) -> replot does it automatically for us
  - or, redirect current plot and save it in another format: set terminal postscript; set output "messdat.ps"; replot; ! ls *.ps -> messdat.ps
  - save "messdat.plt"; load "messdat.plt": store and load current plot (in gnuplot format)
  - The command test: shows you the setting plotted, i.e. you will see the setting of each line, such as color and thickness
 - 5.9.9) using gnuplot from scripts or bash
  - gnuplot messdat.plt: plots file and exits directly:
   - add pause -1  to last line and the plot will wait until pressing a key, or
   - gnuplot -persist messdat.plt
   - executing messdat.plt as a script: head -1 messdat.plt -> #!/usr/bin/gnuplot -persist
   - Using from shellscripts:
    - echo 'plot "messdat.dat" using 1:2 t "1999" with lp' | gnuplot -persist, or using HERE Document
    - FILE=messdat.dat; gnuplot -persist <<PLOT
    set xrange [0:6]
    ...
    plot "$FILE" using 1:2 t "1999".......
    PLOT
 - 5.9.10) Plot-Styles
  - set style data lp/steps: lp linepoints
  - Labels:
   - set label "string" at PointX,PointY: put a label at point (x,y) 
   - set title "string"
   - set linestyle 1 linetype 1 linewidth 1 pointtype 1;  // linetype e.g. color
     plot "messdat.dat" using 1:2 t "1999" with lp linestyle 1
   - set size Xval,Yval: scaling plot, e.g. set size 0.8,0.8 -> 80% of the original size
   - ...
   
- 6) Functions
 - funktions_name() { kommando1 ; kommando2 ; ... ; kommando_n ; } # before { must be at least one space, before } bust be ; or newline
 - Definition (Bash und Korn-Shell only): function funktions_name { kommando1 ; kommando2 ; ... ; kommando_n ; }
 - shell functions are exwcuted before the script itself (not in a sub-shell). shell functions are access/modify script variables, which are not yet defined
 - unset function -> deletes a function. Korn/Bash shells allow functions and variables to have the same name -> unset -f function will delete function and not the var
 - Export Functions: export -f function_name: Allgemein gibt es keine Möglichkeit, Shell-Funktionen zu exportieren. Ausnahme ist wieder die Bash.
  - Bourne-Shell und Korn-Shell hingegen können keine Funktionen exportieren. Umweg: ". file", file contains definition of function_name
  - Function Libraries .bib: loading by 'source lib.bib' or '. lib.bib'
 - Call Order: if there is a function which matches a name of a intern shell-command (builtin) or extern shell command (PATH) -> Call order:
  - 1) shell function, 2) builtin command, 3) extern shell command (PATH)
  - type command: type hallo -> hallo is a function. type echo -> echo is a shell builtin. type find -> find is /usr/bin/find
  - explicitly calling command using builtin or path-to-command: builtin echo "Hallo Welt". /bin/echo "Hallo Welt"
    Differencies between both echos: builtin echo --help , /bin/echo --help
  - Listing all functions: 
   - set: shows all variables and functions with their definition
   - typeset -f: shows all functions with their definition
   - typeset -F: shows all functions without their definition
 - 6.2) Calling Functions:
  - called functions must be defined before the callinf function
  - recursion: fakul() { value=$1; [ $((value)) -le 1 ] && { echo 1; return; }; echo $(($value * `fakul $value-1` )); }
    fakul $1
 - Function Parameters: given similar to normal scripts: functions_name arg1 arg2 arg3 ... arg_n
  - accessing params using: $1...$9 ${n}. $* $@ $# have same meaning as in scripts.only $0 is reserved for the script name
  - Die Parameter, die Sie an die Funktionen übergeben, haben nichts mit den Kommandozeilenparametern des Scripts zu tun, auch wenn eine Funktion nach demselben Schema arbeitet.
  - $FUNCNAME (Bash only): contains the function name
 - 6.4) Return Values: either using return integer, or by a global variable or by echo result and the main function (program) uses command substitution
  - return [n], 0 <= n <= 255, negative values also possible: if n/return n not used -> the reult of last executed command is returned
   - accessing returned value by $?
  - return with echo and command substitution: variable=`functions_name arg1 arg2 ... arg_n`
   - double() { val=`expr $1 \* 2`; echo $val; } ; val=`verdoppeln 25` ; echo "verdoppeln 25 = $val"
  - returning multiple values: double2() { val1=`expr $1 \* 2`; val2=`expr $2 \* 3`; echo $val1 $val2; }
  - Returning using local variables -> which are accessible in the entire script
   - double() { val=`expr $1 \* 2`; }; double 10; echo $val; -> 20
  - 6.4.4 Functions and exit: exit end the script immediately. function uses exit in case of critical error, such as missing important function argument
- 6.5) Local and Global Variables: In scripts there are only global varfiables and are defined only after their first usage.
 - To avoid that functions use the same global variable twice, it is recommended that each variabl in a function begins with (some letters of) the function name 
 - 6.5.1 Local Variables (Bash and Korn-Shell only): local var=value
  - var="ich bin global"; localtest() { local var="ich bin local"; echo $var; }; echo $var; localtest; echo $var; -> calling script -> ich bin global\nich bin local\nich bin global
  - local variables are also seen in sub functions, i.e., var="global"; f1() { local var="local"; f2; }; f2() { echo $var; }; f1; -> local
- 6.6) alias und unalias: alias name definition: defines an alias. unalias name: deletes an alias. alias: shows all aliases
 - e.g. alias xpwd="du -sh ." ; unalias xpwd ; alias sys="ps -ef | more"; type sys -> sys is aliased to `ps -ef`
 - aliases are only accessed for a use (due to security). Aliases are deleted after logging out.
 - define aliases in .bashrc if you want to access them always
- 6.7) Autoload (Korn-Shell only): loading only needed funtion from a library on need. autoload makes a not executable files from each function in FPATH -> faster than loads the entire library
 - FPATH="$FPATH:/pfad/zur/funktionsdatei"; export FPATH

- 7) Signals: used to control the processes.We ourself can specify how a process reacts on a signal, or we leave the reaction to the system itself
 - 7.1) Basics: Signals are asynchronous events that interrupts (from user level) a process -> used got interprocess communication by senging ints or MACROs
  - There are 3 Categories:
   - System signals: Hardware- und Systemfehler, ILL, TRAP, BUS, FPE, KILL, SEGV, XCPU, XFSZ, IO
   - Device signals: HUP (hang up), INT, PIPE, ALRM, CHLD, CONT, STOP, TTIN, TTOU, URG, WINCH, IO
   - User defined signals: QUIT, ABRT, USR1, USR2, TERM
  - kill l: shows all signal numbers and symbolic names
  - when an event occurrs -> event stored in Prozesstabelleneintrag. the kernel decides how to react on it when activating the process:
   - execute default routine, ot ignore signal, or let the user react on it.
  - 7.2) send signals: kill -SIGNAL PID [ PID ... ] -> SINGAL={number, signal name, signal name starting with SIG}
   - kill –9 1234 == kill -KILL 1234 == kill -SIGKILL 1234
   - if SIGNAL is not given -> default signal SIGTERM=15 is used: Programme, die SIGTERM abfangen, bieten meistens einen »Soft Shutdown« an.
   - It is recommended to try SIGTERM before SIGKILL
   - You can not send signals to processes of other users (except super users)
  - 7.3) Signal Trapping (fakh, masyadah): opposite of kill -> trap reacts on signals and prevets exiting shell scripts
   - trap 'kommando1; ... ; kommaond_n' Signal-Number: when signal number is received, the commands in single quotes are executed and then the shell will resume executing
   - trap 'echo SIGINT erhalten' 2; i=0; while [ $i -lt 5 ]; do echo "Bitte nicht stören!"; sleep 2; i=`expr $i + 1`; done # (Strg)+(C) or kill –SIGINT PID_von_trap1 -> executes echo SIGINT erhalten
   - Trapping multiple signals:
    - trap 'echo SIGINT erhalten' 2; trap 'echo SIGTERM erhalten' 15, or
    - trap 'echo Ein Signal (SIGINT/SIGTERM) erhalten' 2 15
   - Trapping SIGKILL/SIGSTOP is not supported
  - 7.3.1) Signal Handlers (Functions):
   - sighandler_INT() { printf "Habe das Signal SIGINT empfangen\nSoll das Script beendet werden (j/n) : "; read; if [[ $REPLY = "j" ]]; then echo "Bye!" exit 0; fi; }; trap 'sighandler_INT' 2;...
   - Verwenden Sie in der Korn-Shell innerhalb von Funktionen die trap-Anweisung, dann sind die mit ihr eingerichteten Signale nur innerhalb dieser Funktion gültig.
   - kill -HUP PID_of_dämon_oder_server: Konfiguration neu laden fuer Daemonen or sent to a process when its controlling terminal is closed. (It was originally designed to notify the process of a serial line drop.)
    - trap 'readconfig' 1; readconfig() { . aconfigfile; /*contains values for a,b,c*/ } a=1; b=2; c=3; while [ 1 ]; do echo "Werte (PID:$$)"; echo "a=$a"; echo "b=$b"; echo "c=$c"; sleep 5; done
  - 7.3.2) exiting loops with signals: trap 'break' 2; while [ 1 ]; do echo "$i. Schleifendurchlauf"; sleep 1; i=`expr $i + 1`; done; echo "Nach dem $i Schleifendurchlauf abgebrochen"
   - 7.3.3) Exiting Scripts with Signals -> Free ressources before exiting: trap 'rm atempfile.tmp ; exit 1' 2
   - 7.3.4) Catching Ending of Shell or Script (e.g. with command exit):
    - Ending a script: trap 'exithandler' 0 # exithandler must should not contains the exit command, because the script is exiting now
    - Ending a Shell: script.name=onexit{ echo "Alles erledigt – Shell mit ENTER beenden"; read} -> on console: trap '$SHELL $HOME/dasEnde' 0
    - Damit die Datei »onexit« mit wichtigen Hinweisen nach jedem Verlassen einer Shell dauerhaft zur Verfügung steht, sollten Sie die Zeile trap '$SHELL $HOME/dasEnde' 0 in die Datei .profile eintragen.
   - 7.3.5) Ignoring Signals: trap '' Signalnummer
   - 7.3.5) Reseting Signals: trap Signalnummer-List
   - trap -> shows signals which should be catched
   
- 8.1) Process Priorities:
 - Each process hat a priority, e.g. system process has a higher priority that a user process
 - Multitasking OS: 1 CPU can serve only on process at the same time -> multitasking. Scheduler assign each process a time slot. Moreover each process hat a priority
  - System process: has a higher priority, which can not be changed by users
  - Real time process: time critical processes -> has higher priority as time sharing processes
  - Time sharing: processes share CPU as fair as possible. each process take a time slot (size depends on #processes and CPU perfomance)
  - Each process has a priority.
  - In order to stay fair and consider priorities -> process priority is recomputed after each execution
  - Commands: nice/renice can affect the process priority. ps -l show NI (NICE) value. We can change process priority by setting -20 (highest) <= NI <= 19 (lowest) 
  - Commands starting in a shell take the same prio as the shell
  - renice PRIO PID: e.g. renice +10 1234 -> 1234: Old Priority: 0, new Priority: 10
   - setting a higher priority (even to original prio) need a root rights, i.e. su -c 'renice -5 1234'
- 8.2) Waing for other Processes:
 - wait PID: wait until PID ends -> wait returns the return values of PID. value 127 means -> process does not exist
 - wait (without PID): waits for all active child processes to end -> return value = 0
 - e.g.: sleep 10 & -> wait $!; echo $? -> https://phoenixnap.com/kb/bash-wait-command
- 8.3) background and foreground processes
 - cmd/script & -> execute cmd/script in background. If script need user input such as read-command -> script is stopped -> ps -l -> a stopped process has T (traced) -> 7249 pts/41   T      0:00 /bin/bash -> fg %1 (%job_specification)
- 8.4) Protecting background processes (nohup)
 - shell is closed -> SIHHUP=1 sent to all processes -> bg processes will be closed (not in SuSE 9.1!!!)
 - nohup cmd args & -> stdout/stderr redirected to nohup.out, if failed to $HOME/nohup.out, if failed -> error
  - return result 126: command could not be started. 127 -> command not found
  - same effect by using trap '' 1; cmd args
- 8.5) Subshells: ( kommando1 ; ... ; kommando_n ) or using new lines instead of ;
 - starts a subshell, and returns the result of the last executed command. the subshell copies all environment variables by value
- 8.6) Communication between Scripts
 - by exporting variables: all scripts will see the same variables
 - by passing as arguments $1...$9...${n}: in script1: ./script2 $a $b $c
 - by using temp files: e.g. one process writes in file and the other process reads from it
  - script1: IFS='\n'; for var in `ls -l`; do echo $var; done > file.tmp; ./script2
    script2: while read line; do echo $line; done < file.tmp
    Without redirection -> use pipe: ./script1 | ./script2
  - by returning data -> calling scripts use command substitution: script1: var=`./script2`; set $var; echo "$1; $2; $3". script2: echo var1=wert1; var2=wert2; var3=wert3; echo $var1 $var2 $var3
    another example script1: var=`./script2`; i=1; for wert in $var; do echo "$i: $wert"; i=`expr $i + 1`; done
    another example script1: ./script2 | while read wert; do for val in $wert; do echo "$val"; done ; done # linewise reading
 - by using a named pipe:
  - PipeServer: mknod meine_pipe p; while true; do read zeile < meine_pipe; echo $zeile; done
    Vorteil: Die anderen Scripts, die Daten in diese Pipe schicken, werden nicht blockiert, weil immer auf der anderen Seite des Rohrs der Server »PipeServer« darauf wartet.
 - 8.6.3) Synchronizing Scripts using signals:
  - FILE=tmpfile.tmp; rm $FILE; touch $FILE; while true; do if [ -r $FILE ]; then echo "Datei wird gelesen ..."; sleep 1; ./script_zum_Lesen; chmod 0200 $FILE; fi
                                                            if [ -w $FILE ]; then echo "Datei ist bereit zum Schreiben ..."; sleep 1; ./script_zum_Shreiben; chmod 0400 $FILE; fi; sleep 1; done
- 8.7) Job Management:
 - sleep 10 & -> [1] 5915 -> i.e. [JOB_NUMBER] PID
 - jobs: shows all background jobs
 - CTRL-Z stopping a foregrounf job (SIGSTOP) -> [1]+  Stopped (state)         du /
  - kill -SIGCONT %1 or kill -SIGCONT PID continues job 1
  - kill %1 == kill -SIGKILL %1 -> ends job 1
  - kill -SIGTERM %1 -> terminates job 1
  - bg %1: sends job 1 into background.  bg or bg %: send last stopped job (current job) into background.
- 8.8) Execution of scheduled scripts: e.g. for backups/ checking consistency, logging
 - Daemon (disk and execution monitors): Background process waiting for tasks to execute
 - Cron Daemon: define and delegate tasks to cron for execution. This is done in crontab. The PC must run at execution time. Some distributions use anacron to guarantee that the tasts are executed even if the PC is shut down
  - crond reads crontab in specific time intervals (usually each minute) and execute defined tasks. it is enough to define a task in crontab
  - cron task should not use stdin (read) and stdout. stdin/stdout should be redirected. The output is sent usually to crontab's owner
  - cron task should be careful using environment variables, because you don't know if these vars exist in the shell, which is started by crond
  -> crontab can contain env. vars -> shells started by crond use these env. vars.:
   - LOGNAME or USER = crontab's owner
   - HOME=LOGNAME/USER's home dir
   - PATH: be sure that it contains $PATH when cron task (script) is executed -> scripts should use absolute paths to avid problems with PATH var
   - if the cron task (script) want to know that it is in execution -> execute tty -s; assert echo $?==0 # -s := silent because cron tasks use no stdout/stdin
   - crontab format: 0-59 (minutes) 0-23 (hours) 1-31 (day) 1-12 (month) 0-7 (dayOfMonth 0=7=sunday) [User] (name, only for root) command -> 6/7 columns for normal user/root
   - * * * * * $HOME/meinscript -> each minute,  0 10–14 * * * $HOME/meinscript every day at 10,11,12,13,14 oclock,  0 10–12,16,20–23 * * * $HOME/meinscript every day at 10, 11, 12, 16, 20, 21, 22, 23 oclock
     0 */4 * * * $HOME/meinscript every daty at 0,4,8,12,16,20 oclock,  0 23 15 * 6 $HOME/meinscript (every 15. of each month AND every saturday) at 23 oclock
     0 23 * * 0–6/2 $HOME/meinscript jeden zweiten Tag um 23 UHr
   - crontab -e: edit cron file;    contab -l: list all cron jobs;    crontab -r: delete all cron jobs
- 8.9) Shell-Starter-Process and Shell-Profile-Data
 - interactive shell: like calling bash. Not interactive shell: e.g. like calling a script, or ( ... ) or command substitution. Login Shell: called directly after log in
 - system wide initialization files: in /etc or /etc/profile or sometimes in /usr/etc. Some programs pur their config giles in /usr/share/packet/xxxxrc (rc=read command)
  - after logging in  -> /etc/profile is executed -> editable only from admin. login start a shell (specified in /etc/passwd like HOME). This shell set env vars. usually calls /etc/profile more init files
 - user specific init files: in home director
 - Start of a login shell:
  - Bourne-Shell:set environment -> /etc/profile -> $HOME/.profile
  - Bash-Shell:set environment -> /etc/profile -> $HOME/.bash_profile, if not found -> $HOME/.bash_login, if not found -> $HOME/.profile
  - Korn-Shell:set environment -> /etc/profile -> $HOME/.profile -> $ENV (usually $HOME/.kshrc)
   - .kshrc contains aliases/functions which can not be exported
 - Start of a not login shell: (remeber: aliases and functions can not be exported)
  - Korn-Shell: $ENV=.kshrc is executed
  - Bash-Shell: - interactive mode (e.g. calling bash): ~/.bashrc is executed
                - interactive mode (e.g. calling a script): $BASH_ENV is executed (if exists -> default ~/.bashrc)
  - Bourne-Shell: nothing
 - Exceptions: Starting subshells by ( ... ) or command substitution or calling a script after a point (e.g. source .bashrc or '. ./bashrc'): nothing is executed -> only an exact copy of environment is copied
 - More for Bash:
  - $HOME/.bash_logout: called when ending/logging out -> should free ressources
  - /etc/inputrc:	In dieser Datei wird die systemweite Vorbelegung der Tastatur für die Bash und andere Programme definiert, welche die C-Funktion readline zum Lesen der Eingabe verwenden. Veränderungen sind dem Systemadministrator (root) vorbehalten.
  - $HOME/.inputrc:	Wie /etc/inputrc, nur dass hier der normale Benutzer eigene Einstellungen vornehmen darf.
- 8.10) Executing Shell Scripts:
 - (./script or bash script) executes script in a subshell. The current shell is blocked until ending 
 - (./script& or bash script&) executes script in a subshell. The current shell is not blocked
 - (. ./script or source ./script) executes script in context of the caller shell
 - There are 3 Phases for script execution:
  - Syntax Checking: the script is read line by line and is checked for syntax
  - Expansion: Aliases- und Tilde-Expansion, command substitution, Variable-Interpolation, Computations (nur Bash und Korn-Shell) and file expasions
  - Command Execution: Execution Order: shell builtin commands (shell functions), Functions, extern commands (in PATH) or binary command or schell scripts
- 8.11) Optimizing Shell Scripts (Advices): speed up 2x until 10x
 - try to use builtin commands
 - use bash/korn shells because they have more builtin commands
 - use always the simplest version of a command (due to portability)
 - use fast commands: e.g. cat is 10x faster than reading with awk and 100x faster than read command
 - avoid reading big data with read command (specially in a loop). read is useful for user input and reading small files -> use cat, grep, sed or awk
 - avoid working with big files: extract important data using grep/sed/awk and save them in tmp file for later work
 - avoid using awk in loops and thus starting awk in each iteration -> write awk script and thus starting awk only once
- 9) Useful Functions:
 - 9.1) eval command line: 
 

