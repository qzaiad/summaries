Meine Ablage
1. Introduction
- buildin commando -> implemented directly in shell
- alias gohome="cd ~"
- who -> which user is logged it (you      tty1         Jan 30 11:14)
- whoami
- ps -f -> current process list. PPID=Parent PID. bash scripts (or here 'ps') are executed in an additional bash -> PPID(7742) = PID(3672)
  UID        PID  PPID  C STIME TTY          TIME CMD
  you       3672  3658  0 Jan20 pts/38   00:00:00 /bin/bash
  you       7742  3672  0 03:03 pts/38   00:00:00 ps -f
- ps PID
    PID TTY      STAT   TIME COMMAND
  63138 pts/6    Ss     0:00 /bin/bash

- scrip finduser -> find / -user you -print 2>/dev/null
- $! -> contains PID of last started background process
- $$ - > own PID
- #!/bin/bash -> She-Bang line
- ./script or bash script -> executes script in a subshell -> e.g. useful to avoid changing environment variables
- source ./script == . ./script (point + space) -> executes scipt in current bash
- Debuggen: enable debugging #!/bin/bash -x or set -x or bash -x script. disable debugging set +x
 - before each script line is executed, it is printed after '+' (actually after $PS4)
 - e.g ps -ef | wc -l -> +ps -ef \n +wc -l 
 - export PS4='[--- LINE: $LINENO ---] ' -> this will print line number when debugging a script
 - $LINENO, die nach der Ausführung immer durch die entsprechende Zeilennummer ersetzt wird.
- Redirection:
 - command > file -> same as command 1> file -> redirect standard stream to file
 - command 2> file -> redirect standard error  stream to file
 - command > file 2>&1 -> redirect both streams to file
 - command >> file -> append to file
 - input redirection: grep audio < find_tot.dat
 - command | tee file -> redirect to standard output AND to file
- Piping cmd1 | cmd 2: connecting standard output of one cmd1 to the standard input of cmd2
- du -c: prints size of directory and its sub directories
- Wildcards (filename expansion): * ? []
 -  [ab] [a-z] datei[12][a] datei[!12] datei[[:digit:]].txt
    [:alnum:]	Buchstaben, Unterstrich und dezimale Ziffern
    [:alpha:]	Groß- und Kleinbuchstaben
    [:digit:]	Dezimale Ziffern
    [:lower:]	Kleinbuchstaben
    [:upper:]	Großbuchstaben
    [:print:]	Nur druckbare Zeichen
    [:space:]	Leerzeichen, Tabulator ...
 - prefix{ muster1, muster2 }suffix -> prefixmuster1suffix prefixmuster2suffix
  - touch datei{orginal{.bak,.txt},kopie{.bak,.txt}} -> dateikopie.bak  dateikopie.txt  dateiorginal.bak  dateiorginal.txt
  - ls datei*{.bak,.txt} -> dateikopie.bak  dateikopie.txt  dateiorginal.bak  dateiorginal.txt
  
- Muster alternatives:
 - shopt [-pqsu] [-o] [optname ...] -> Set and unset shell options.
 - shopt –s extglob: ls @(prozess|promess|process|propan).dat; ls !(prozess|promess|process|propan).dat
 @(pattern1 | patter2 | ... | patternN)	Eines der Muster
 !(pattern1 | patter2 | ... | patternN)	Keines der Muster
 +(pattern1 | patter2 | ... | patternN)	Mindestens eines der Muster
 ?(pattern1 | patter2 | ... | patternN)	Keines oder eines der Muster
 *(pattern1 | patter2 | ... | patternN)	Keines, eines oder mehrere Muster
 - Tilde-Expansion: ~ home folder, ~USER home folder of USER, ~- previsited folder, ~+ same as pwd -> echo ~ ~- ~+ -> /home/qahmad /home/qahmad /home/qahmad/scripts

2. Variables
- Variable-Interpolation: datum=$(date +%Y_%m_%d); mkdir backup_$datum
- undefined variables -> empty string. Use option -u to catch show warning about undefined variables
 - sh -u ./aerror -> ./aerror: line 10: var3: unbound variable
- varialbes should be used with {} in order to avoid problems:
 - file=back_; cp datei.txt $filedatei.txt -> datei.txt copied into ".txt" because there is no variable $filedatei.txt
 - file=back_; cp datei.txt ${file}datei.txt -> datei.txt copied into "back_datei.txt"
- delete variables: unset variable-name
- Constants using readonly: readonly x=5; x=6 -> bash: x: readonly variable
 - Bei der Verwendung von readonly handelt es sich um eine Zuweisung! Daher erfolgt auch das Setzen des Schreibschutzes ohne das Zeichen $.
- Integer Arithmetik (UNIX-Befehl expr) -> expr 5 + 4 (must be separated by ' ')
 - preceed * with \: expr 2 \* 2 -> 4
 - command substitution using `` (Gravis character): z=`expr $x + $y` -> store result in z
- Integer Arithmetik (Bash and Korn Shell only)
 - ((z=5+5)) or z=$((5+5)) -> z=10: '((' tells the shell that an arethmetik expression follows
 - bash only z=$[5+5]
 - let z=x+y (builtin command) equivalent to z=$((x+y))
 - Arithmetic Operators: + - * / % (modulo) << >> & ^ | += -= *= /= %= <<= >>=  &= ^= |=
 - typeset or declate: set or declyre variable type
  - typeset -i a b c; a=1; b=2; c=a+b (without $ symbol); d=\(a+b\)*c
- Floating Point Arithmetik with bc (UNIX command)
 - Variable=`echo "[scale=n ;] Rechenoperation" | bc [-l]`
 - bc -l -> use mathematic library funcs s(x) c(x) a(x) l(x) e(x) / sin cos atan log e^
 - bc expects lines of arithmetic expressions from stdin and outputs result lines into stdout
- Convert Numbers with bc: bin/hex/dec
 - ibase/obase: input/output base -> any number between 2 and 16
  - dez=`echo "obase=10 ; ibase=2 ; 1111011" | bc` -> 123
- Strings:
 - cut -c5 gedicht.txt: cut only the 5th character of each line - cut 
 -c5-10; -c5-; -c1,3,5,6,7–12 - cut -d\; -f1,3 datei.csv: -d for 
 delimiter   -f for field -> cut the first and the third columns - 
 paste: opposite of cut - paste -d\; namen.txt nummer.txt > 
 zusammen.txt -> Qassem;+97246... - tr - translate or delete characters 
 - tr von_Zeichen nach_Zeichen - tr a b < gedicht.txt: replace all 
 occurrences of a by b - cut -d\; -f1,3 datei.csv | tr \; '\t' -> 
 tot;17:32------->tot     17:32 (replace ; by tabulator) - tr '[a-z]' 
 '[A-Z]' < gedicht.txt -> ranges must be included in '' to avoid file 
 expansion by the shell - tr -d ' ','\n' < gedicht.txt -> delete all 
 spaces and newlines - tr -s ' ' ' ' < datei.txt: -s --squeeze-repeats 
 replaces all sequances of ' ' by a ' ': "Q.   Abu   Ahmad" -> "Q. Abu 
 Ahmad" - awk: laenge=`echo $zeichen | awk '{print length($zeichen)}'` 
 -> assign value by command substitution using `` - Awks 
 Builtin-Stringfunktionen
	Funktion				Bedeutung
	tolower str				Komplette Zeichenkette in Kleinbuchstaben
	toupper str				Komplette Zeichenkette in Großbuchstaben
	index(str, substr)		Gibt die Position zurück, wo substr in str anfängt
	match(str, regexpr)		Überprüft, ob der reguläre Ausdruck regexpr in str enthalten ist
	substr(str, start, len)	Gibt einen Teilstring ab Postion start mit der Länge len aus str zurück.
	split(str, array, sep)	Teilt einen String in einzelne Felder auf und gibt diese an ein Array. sep dient dabei als Feldtrenner.
	gsub(alt, neu, str)		Ersetzt in str den String alt durch neu
	sub(alt, neu, str)		Ersetzt erstes Vorkommen von alt durch neu in str
	sprintf("fmt",expr)		Verwendet die printf-Formatbeschreibung für expr
- Extended String Funktions for Bash and Korn Shells
 - $(#zeichenkette): String-Length
 - x="./home/you/Dokuments/shell/kapitel2.txt"
 - ${var#pattern}:  find shortest match from left and return var without matched pattern: echo ${x#*/} -> home/you/Dokuments/shell/kapitel2.txt
 - ${var##pattern}: find longest match from left and return var without matched pattern:  echo ${x##*/} -> kapitel2.txt
 - ${var%pattern}:  find shortest match from right and return var without matched pattern: echo ${x%/*} -> ./home/you/Dokuments/shell
 - ${var%%pattern}: find longest match from right and return var without matched pattern: echo ${x%%/*} -> .
 - String rechts oder links abschneiden (Korn-Shell only)
  - typeset -L5 str; str=1234567890 -> 12345
  - typeset -R3 str; str=1234567890 -> 890
 - (Teil-)Strings ausschneiden (Bash only)
  - ${var:start:length} or ${var:start}: str=1234567890; echo ${str:3:6} -> 456789; echo ${str:5} -> 67890
- Quoting and Command-Substitution
	'	Single Quote, einfaches Anführungszeichen
	"	Double Quote, doppeltes Anführungszeichen (oder Gänsefüßchen)
	`	Back Quote, Backtick, Gravis-Zeichen, umgekehrtes einfaches Anführungszeichen
 - Hinweis   Wie bei einer Pipe, geht auch bei einer Kommando-Substitution die Fehlermeldung verloren.
 - Die Verwendung von $(...) gegenüber `...` hat natürlich nur einen rein optischen Vorteil. Die Form $(...) lässt sich erheblich einfacher lesen, aber wem nützt das was, wenn es die Bourne-Shell nicht kennt. Wer sich sicher sein kann, dass seine Scripts auch immer in einer Bash oder einer Korn-Shell ausgeführt werden, der kann sich frohen Herzens damit anfreunden. Damit fällt wenigstens bei der Quoterei die Back Quote weg, und Sie müssen nur noch die Single und Double Quotes beachten.
- Arrays (Bash and Korn-Shell only)
 - Assigning by: a[x]=value; Accessing by: ${a[x]}
 - it would be better to declare a variable as an array: typeset –ir array
 - initializing:
  - Bash-Shell
   - no limits to array size
   - a=(null eins zwei drei vier fuenf ...)
   - a=([2]=zwei drei) -> a[0] and a[1] would unset a then initializes a
  - Korn-Shell
   - set -A array null eins zwei drei vier fuenf
   - limit to array size: 512, 1024 oder maximal 4096
 - ${array[*]} or ${array[@]} would print the whole array (space separated)
 - ${#array[*]} or ${#array[@]}: array size
 - delete an array or an element: unset array; unsert array[2]
 - array_kopie=(${array_quelle[*]}) (bash) or set -A array_kopie ${array_quelle[*]} (Korn)
  - Achtung: Hierbei gibt es noch eine üble Stolperfalle. So löscht man beispielsweise in der Bash array[1] mit unset und kopiert dann das array, so steht in array_kopie[1] der Inhalt von array[2].
 - x=(Muhammad Rashid Qassem Samih); echo ${x[0]:0:3} ; echo ${x[*]:1:3} -> Muh\nRashid Qassem Samih
- Export Variables: sometimes there is a need to share a variable among multiple scripts -> export variable
 - export variable=1234; export var1 var2 var3 var4
 - scripts are executed in a subshell. all exported variables are copied by value, that is, subshells cannot modify variables of the parent shell
 - The POINT-COMMAND: Executing scripts in the current shell: ". ./script" or "source ./script"
  - main usage: reloading of config files: . ./bashrc
  - Es gibt außerdem noch zwei Anwendungsfälle, wo bei einem Script die benutzerdefinierten Variablen ohne einem Export sichtbar sind. Dies geschieht durch die Verwendung von Kommando-Substitution `...` und bei einer Gruppierung von Befehlen (...). In beiden Fällen bekommt die Subshell (bzw. das Shellscript) eine komplette Kopie aller Variablen der Eltern-Shell kopiert.
  - automatic export: typeset -x var=value -> x is exported automatically in subshells
  - automatic export is stopped by: typeset +x var
  - 'declare' is a synonym to 'typeset'
  - typing typeset or declare alone with print all the exported variables
- Environment Variables: Wenn Sie ein Script, eine neue Shell oder ein Programm starten, so wird diesem Programm eine Liste von Zeichenketten (genauer Array von Zeichenketten) übergeben. Diese Liste wird als Umgebung des Prozesses bezeichnet. Gewöhnlich enthält eine solche Umgebung zeilenweise Einträge in Form von: variable=wert
  Somit sind Umgebungsvariablen zunächst nichts anderes als global mit dem Kommando export oder typeset -x definierte Variablen.
- Automatic Shell-Variables: 
 - $0 script name: für Fehlermeldungen verwendet, zum Beispiel um anzuzeigen, wie man ein Script richtig anwendet bzw. aufruft
 - $$: PID of the current shell
 - $?: last exit code
 - $!: PID of last process started in background
 - $1 bis $n	Argumente aus der Kommandozeile
 - $*	Alle Argumente aus der Kommandozeile in einer Zeichenkette
 - $@	Alle Argumente aus der Kommandozeile als einzelne Zeichenketten (Array von Zeichenketten)
 - $#	Anzahl aller Argumente in der Kommandozeile
 - $_	(Bash only) Letztes Argument in der Kommandozeile des zuletzt aufgerufenen Kommandos
 - $RANDOM: random number between 0 and 32767 -> RANDOM=1; echo $RANDOM -> 17767
 - LINENO	Diese Variable enthält immer die aktuelle Zeilennummer im Shellscript. Wird die Variable innerhalb einer Scriptfunktion aufgerufen, entspricht der Wert von LINENO den bis zum Aufruf innerhalb der Funktion ausgeführten einfachen Kommandos. Außerhalb von Shellscripts ist diese Variable nicht sinnvoll belegt. Wird die LINENO-Shell-Variable mit unset gelöscht, kann sie nicht wieder mit ihrer automatischen Funktion erzeugt werden.
 - OLDPWD	Der Wert ist das zuvor besuchte Arbeitsverzeichnis; wird vom Kommando cd gesetzt.
 - OPTARG	Der Wert ist das Argument der zuletzt von getopts ausgewerteten Option.
 - OPTIND	Enthält die Nummer (Index) der zuletzt von getopts ausgewerteten Option
 - PPID	Prozess-ID des Elternprozesses (Parent Process ID = PPID); eine Subshell, die als Kopie einer Shell erzeugt wird, setzt PPID nicht.
 - PWD	Aktuelles Arbeitsverzeichnis
 - RANDOM	Pseudo-Zufallszahl zwischen 0 bis 32767; weisen Sie RANDOM einen neuen Wert zu, so führt dies dazu, dass der Zufallsgenerator neu initialisiert wird.
 - REPLY	Wird vom Shell-Kommando read gesetzt, wenn keine andere Variable als Rückgabeparameter benannt ist und bei Menüs (select) enthält REPLY die ausgewählte Nummer.
 - SECONDS	Enthält die Anzahl von Sekunden, die seit dem Start (Login) der aktuellen Shell vergangen ist. Wird SECONDS ein Wert zugewiesen, erhöht sich dieser Wert jede Sekunde automatisch um eins.
 - ERRNO	Fehlernummer des letzten fehlgeschlagenen Systemaufrufs
 - BASH	Kompletter Pfadname der aktuellen Shell
 - BASH_VERSION	Versionsnummer der Shell
 - EUID	Beinhaltet die effektive Benutzerkennung des Anwenders. Diese Nummer wird während der Ausführung von Programmen, bei denen das SUID-Bit aktiviert ist, gesetzt.
 - HISTCMD	Enthält die Nummer des aktuellen Kommandos aus der Historydatei
 - HOSTTYPE	Typ des Rechners. Für Linux kommen u. a. die Typen i386 oder i486 in Frage.
 - OSTYPE	Name des Betriebssystems. Da allerdings die Variable OSTYPE den aktuellen Wert zum Übersetzungszeitpunkt der Bash anzeigt, ist dieser Wert nicht zuverlässig. Re-kompilieren Sie bspw. alles neu, ändert sich dieser Wert nicht mehr. Zuverlässiger ist da wohl das Kommando uname.
 - PROMPT_COMMAND	Hier kann ein Kommando angegeben werden, das vor jeder Eingabeaufforderung automatisch ausgeführt wird.
 - SHLVL	Steht für den Shell-Level. Bei jedem Aufruf einer neuen Shell in der Shell wird der Shell-Level um eins erhöht; der Wert 2 kann z. B. innerhalb eines Scripts bestehen, das aus einer Login-Shell gestartet wurde. Eine Möglichkeit, zwischen den Levels zu wechseln, gibt es nicht.
 - UID	Die User-ID des Anwenders. Diese Kennung ist in der Datei /etc/passwd dem Benutzernamen zugeordnet.
- Parameter and Arguments
 - ls -l file: arguments are 'l' and 'file'
 - CLI-Parameter (also called Position-Parameters) $1 bis $9. $0 contains the command name. The Shalee-Variable $IFS
 - i.e. IFS="," -> script_file arg1,arg2,arg3...
 - $*	Alle Argumente aus der Kommandozeile in einer Zeichenkette
  - for i in $*; do echo i done:
    - if $*=eine variable Anzahl von Argumenten -> 5 arguments are printed
    - if $*="eine variable Anzahl von Argumenten" -> 1 argument but the for loop would print 5 lines, because for uses IFS=" " to separate between tokens
    - for i in "$*" -> would see one argument and would print only one line
 - $@	Alle Argumente aus der Kommandozeile als einzelne Zeichenketten (Array von Zeichenketten)
 - Merke   Alle Argumente (auch mehr als 9) sind durch $* oder $@ erreichbar. $* liefert sie als ein Wort, verkettet mit Leerzeichen, und $@ liefert sie als ein Argument pro Wort.
 - $#	Anzahl aller Argumente in der Kommandozeile
 - shift [n]: $1...$n; shift -> $2=$1 $3=$2 ...$n-1=$n $#=$#-1
 - ./script Jürgen von Braunschweig 30 -> there are 4 arguments
 - ./script Jürgen "von Braunschweig" 30 -> there are 3 arguments
 - If there is more than 9 arguments, then the are accessed as followed: ${n}, e.g. echo ${99}
 - set arguments $1...$n: set arg1 arg2 ... argn -> $1...$n are set (IFS must contain at least one space)
 - set -- -a -b -c -> use -- in order to set -arg into $1...n variable
 - set --: unsets all position arguments (Korn/Bash). Other Shells use: set ""
 - example: IFS=" "; set `who | grep qahmad'
 -                   set `date`; echo "$3.$2.$6 um $4"
 - getopts: Evaluating CLI Options -> getopts Options Variable [Arguments]
  - Options must be before filenames
  - learn by example
	while getopts abc:D: opt 2>/dev/null # 2>/dev/null to supress error generated by getopts. c: and D: -> Options c and D expects an argument
	do
	   case $opt in
		   a) echo "Option a";;
		   b) echo "Option b";;
		   c) echo "Option c : ($OPTARG)";; # OPTARG contains argument for option c
		   D) echo "Option D : ($OPTARG)";;
		   ?) echo "($0): Ein Fehler bei der Optionsangabe" # if ?) not found -> getopts outputs an error and exit with error code (e.g. missing argument or unknown option)
	   esac
	done
  - OPTIND: contains option index. it is initialized by one and is increased by one for each call of getopts
            Wenn eine Kommandozeile mehrfach eingelesen werden soll, muss der Index manuell zurückgesetzt werden.
  - getopts:
   - return 0: Option found
   - return error code:
    - end of arguments reached, or
    - error found:
     - to supress error messages:
      - ':' must be first in getopts options, i.e. 	while getopts :abc:D:, or
      - OPTERR=0
 - Defaults for Variables
  - directory=${1:-`pwd`}; ls -ld $directory | grep ^d -> if $1 is missing, set directoy to pwd
 ${var:–wort}	return var.size() ? var : wort
 ${var:+wort}	return var.size() ? wort : null
 ${var:=wort}	return var.size() ? var : (var = wort && return var)
 ${var:?wort}	if(var.size()) return var; else{ echo "bash: xx: " (wort.size() ? wort : "parameter null or not set") }
 NULL = Variable is unset or is ""
4. Control Structures:
- if [ bedingung ]; then befehl(e); elif [ bedingun ]; then... else befehl(e) fi # OR
 if [ bedingung ]
then
   # Ja, Bedingung war erfolgreich
   # ... hier Befehle für erfolgreiche Bedingung verwenden
else
...
fi
- Example: if grep "^$1" /etc/passwd > /dev/null 2>&1; then .... fi # OR
- grep "^$1" /etc/passwd > /dev/null
  if [ $? -ne 0 ]; then ... fi
- Command chaining via pipes with if:
 - @? -> result of last command in the chain
 - e.g.: if ls -l /usr/include | grep $1 | wc -l -> $?==0, even if $1 is Null or pattern not found
- Evaluating PIPESTATUS (Bash only)
 - PIPESTATUS is an array and contains the exit codes of the last executed commands (${PIPESTATUS[0]}...${PIPESTATUS[n]})
 - 
- The Command test:
 - if test Ausdruck <-> if [ Ausdruck ] (symbolic form of test)
 - there MUST BE a space after each expresion. [ 1 -lt 2 ] or test 1 -lt 2.
 - Integer comparison: var1 -eq -ne -lt -gt -le -ge var2
 - Integer comparison with let command (Bash and Korn-Shell only):
  - let z=x+y; ((z=x+y))
  - if (( $a > $b )) or if let "$a > $b"
 - String Comparison: [ "$var1" = "$var2" ] [ "$var1" != "$var2" ] [ –z "$var" ] [ –n "$var" ]
  - We should include each variable in double quotes in order to avoid errors when $var does not exist or var consists of multiple tokes (separated by ' ')
 - String Comparison (Bash and Korn-Shell only):
  - [[ "$var1" == "$var2" ]] [[ "$var1" != "$var2" ]] [[ –z "$var" ]] [[ –n "$var" ]] [[ "$var1" > "$var2" ]] [[ "$var1" < "$var2" ]]
    [[ "$var" ==/!= pattern ]] -> pattern must be on the right side and must not include double quotes
                                  pattern might include *, ? und [ ]. E.g. if [[ "$1" = *ist* ]]
 - Status of files: if [ -Operator Datei ]
-Operatoren zum Testen des Dateityps 
	–b DATEI	Datei existiert und ist ein block special device (Gerätedatei).
	–c DATEI	Datei existiert und ist ein character special file (Gerätedatei).
	–d DATEI	Datei existiert und ist ein Verzeichnis.
	–f DATEI	Datei existiert und ist eine reguläre Datei.
	–h DATEI	Datei existiert und ist ein symbolischer Link (dasselbe wie –L).
	–L DATEI	Datei existiert und ist ein symbolischer Link (dasselbe wie –h).
	–p DATEI	Datei existiert und ist eine named Pipe.
	–S DATEI	Datei existiert und ist ein (UNIX-Domain-)Socket (Gerätedatei im Netzwerk).
	–t [FD] 	Ein Filedescriptor (FD) ist auf einem seriellen Terminal geöffnet.
- Operatoren zum Testen der Zugriffsrechte auf eine Datei
	–g DATEI	Datei existiert und das setgid-Bit ist gesetzt.
	–k DATEI	Datei existiert und das sticky-Bit ist gesetzt.
	–r DATEI	Datei existiert und ist lesbar.
	–u DATEI	Datei existiert und das setuid-Bit ist gesetzt.
	–w DATEI	Datei existiert und ist beschreibbar.
	–x DATEI	Datei existiert und ist ausführbar.
	–O DATEI	Datei existiert und der Benutzer des Scripts ist der Eigentümer (owner) der Datei.
	–G DATEI	Datei existiert und der Benutzer des Scripts hat dieselbe GID wie die Datei.
- Operatoren zum Testen von charakteristischen Eigenschaften
	–e DATEI	Datei existiert.
	–s DATEI	Datei existiert und ist nicht leer.
	DATEI1 –ef DATEI2	Datei1 und Datei2 haben dieselbe Geräte- und Inodennummer und sind somit Hardlinks.
	DATEI1 –nt DATEI2	Datei1 ist neueren Datums (Modifikationsdatum, nt = newer time) als Datei2.
	DATEI1 –ot DATEI2	Datei1 ist älter (Modifikationsdatum, ot = older time) als Datei2. 
- Logical Operators
 - Bash and Korn-Shell only: && || !
 - All: [ expr1 -a expr2 ] [ expr1 -o expr2 ] [ ! expr ]
 - Example: if [ -f $file -a -w $file ] <-> if [ -f $file ] && [ -w $file ]
            number=${1:-"5"}; if [ $number -gt 0 -a $number -lt 11 ] or if (( $number > 0 )) && (( $number < 11 ))
            if (( $number == 1 )) || (( $number == 2 )) <-> if [ $number -eq 1 -o $number -eq 2 ]
            if [ $answer = "j" -o $answer = "ja" ] <-> if [[ $answer == "n" ]] || [[ $answer == "nein" ]]
 - Klammerung muss außerhalb von [[ ]] stattfinden: if ([[ $var1 == "abc" ]] && [[ $var2 == "cde" ]]) || ( [[ $var3 == "abc" ]] )           
 - # Innerhalb von eckigen Klammern müssen runde Klammern ausgeschaltet werden: if [ \( "$var1" = "abc" -a  "$var2" = "cde" \)  -o "$var3" = "abc" ]
 - # Bash und Korn-Shell: if (( $var1 == 4 )) || ( (( $var2 == 2 )) && (( $var3 == 3 )) )
   # alle Shells: if [ $var1 -eq 4 -o \( $var2 -eq 2 -a $var3 -eq 3 \) ]
 - Verwendung von Klammern bei Ausdrücken
	Ausdruck für	Ohne Klammern	Klammerung	Shell
	Zeichenketten	[[ Ausdruck ]]	([[ Ausdruck ]])	Bash und Korn
	Zeichenketten	[ Ausdruck ]	[ \( Ausdruck \) ]	alle Shells
	Zahlenwerte	(( Ausdruck ))	( (( Ausdruck )) )	Bash und Korn
	Zahlenwerte	[ Ausdruck ]	[ \( Ausdruck \) ]	alle Shells
	Dateitest	[ Ausdruck ]	[ \( Ausdruck \) ]	alle Shells
	Dateitest	[[ Ausdruck ]]	([[ Ausdruck ]])	nur Korn
- Short Circuit-Tests: using && || with commands:
 - cmd1 && cmd2: execute cmd2 iff cmd1 succeeds
 - cmd1 || cmd2: execute cmd2 iff cm1 fails
- case:
case "$var" in
   muster1)   kommando		# or (muster1) -> Dies verhindert, dass bei Verwendung von case in einer Kommando-Substitution ein Syntaxfehler auftritt
              ...			# muster might include *, ? oder [ ]. Ebenso können Sie eine Muster-Alternative wie *(...|...|...); @(...|...|...)
              kommando ;; 	# ;; := break -> if does not exists it continues to muster2 and if matches muster2 -> execute muster2.commands...
   muster2)   kommando
              ...
              kommando ;;
   mustern)   kommando
              ...
              kommando ;;
   *)         default action
esac
 - examples:
  - Mo)   echo "Mo : Backup Datenbank machen" ;;
  - Mo|Mon)   echo "Mo : Backup Datenbank machen" ;;
  - [jJ])
  - [jJ][aA])
  - [jJ]|[jJ][aA])
  - case with options
   - -[tT]|-test)
   - -[hH]|-help|-hilfe)
   - while getopts tThH opt 2>/dev/null; do case $opt in t|T) echo "Option test";; h|H) echo "Option hilfe";; ?) echo "($0): Ein Fehler bei der Optionsangabe"...
4.9 Loops
- for var in liste_von_parameter; do kommandos...; done
- for x in 1 2 3 9; do echo "x=$x"; done
- Process argeuments with for: for datei in "$@"; do...; done <-> for datei; do...; done
 - Lassen Sie den Zusatz in "$@" weg, setzt die for-Schleife diesen automatisch ein -> for datei; do...; done
- For and filename substitution: for file in *; for file in *.txt *.c log[1-9].txt; for file in * .*; 
- handle failed muster-resolving ->
	for datei in *.jpg
	do
	   case "$datei" in # this is not a switch statement -> it handles failing muster resolving (*.jpg)
		  *.jpg)   echo "Keine Datei zum Muster *.jpg vorhanden" ;;
		  *)       echo $datei ;;
	   esac
	done
- For and Arrays (Bash and Korn-Shell only): array=( 1 2 3 4 5 6 7 8 9 ); for value in ${array[*]}
- For and Counters (Bash only Ab Version 2.0.4): for (( var=Anfangswert ; Bedingung ; Zähler /*i++ or i-- or ((i+=x)) or ((i-=x))*/ )); do...done
- example:
	array=( $* )
	for((i=0; i<$#; i++)); do echo "Argument $i ist ${array[$i]}"; done
	for((i=5; i>0; i--)); do echo $i; sleep 1; done
	for((i=100; i>0; ((i=i/2)) )); do echo $i; done
- while loop: [bedingung or command]; do.....done -> while [ $i -lt $# ]  or  while [ "$input" != "ende" ]
- until loop: opposite of while -> execute as long as condition is false
 - while [ ! "$input" = "ende" ] <-> until [ "$input" = "ende" ]
- control jumps: continue; break; exit; -> analog to c++
5. Terminal-In- and Output
- Terminal: at first unix time there was only one PCs. Multiple terminals (screens) were connected to the same PC.
 - A proccess called getty (in linux called mingetty) waits for a terminal to connect and authenticate -> then it opens a session
 - Session := The time after authentication until exit
 - Nowadays there are Terminal-Emulators -> are programms which pretend to be a real terminal
 - Virtual-Terminals: CTRL+ALT+F1...CTRL+ALT+F7
 - ps -e | grep getty -> (...3092 tty1     00:00:00 getty...). if e.g. tty3 is not in the list -> then some user is logged in tty3. when the user logs out -> a getty process will then start on tty3
 - Pseudo-Terminal (pts or ttyp under unix) -> the commay tty tells you in which pseudo terminal you are logged in (e.g /dev/pts/4 or /dev/ttyp1)
 - ls -l /dev/pts -> crw--w----  1 tot tty 136, 37 2005–03–01 22:46 37
- 5.2) Outputs
 - echo [-option] argument1 argument2 ... argument_n -> prints argument1...n + new line
 - echo -n arguments <-> echo -e "arguments\c": does not print newline 
 - echo -e: activate interpretation of escape sequencies
 - Escape Sequencies: \a Alarm-Ton (Beep); \b Backspace; ein Zeichen zurück; \c continue; das Newline-Zeichen unterdrücken; \f	Form Feed; einige Zeilen weiterspringen
   \n Newline; Zeilenumbruch; \r return; zurück zum Anfang der Zeile; \t Tabulator (horizontal); \v Tabulator (vertikal); meistens eine Zeile vorwärts
   \\ das Backslash-Zeichen ausgeben; \0nnn	ASCII-Zeichen in oktaler Form (nur sh und ksh); z. B. aus \0102 wird B (dezimal 66)
   \nnn	ASCII-Zeichen in oktaler Form (nur Bash); z. B. aus \102 wird wird B (dezimal 66)
 - printf format argument1 argument2 ... argument_n
 - printf "Kunde: %-10s Anzahl: %-5d Gegenstand: %15s\n" $1 $2 $3 -> %-10s allign $1 to left ; %15s allign $3 to the right -> "Kunde: J.Wolf     Anzahl: 10    Gegenstand:          Socken"
	text=Kopfstand
	a=3
	b=12345
	printf "|01234567890123456789|\n"
	printf "|%s|\n" $text
	printf "|%20s|\n" $text
	printf "|%-20s|\n" $text
	printf "|%20.4s|\n" $text
	printf "|%-20.4s|\n\n" $text
	printf "Fließkommazahl: %f\n" $a
	printf "gekürzt       : %.2f\n" $a
	printf "Ganzzahl      : %d\n" $b
	printf "gekürzt       : %.2d\n" $b
	printf "erweitert     : %.8d\n" $b
	Das Script bei der Ausführung:

	|01234567890123456789|
	|Kopfstand|
	|           Kopfstand|
	|Kopfstand           |
	|                Kopf|
	|Kopf                |
	Fließkommazahl: 3,000000
	gekürzt       : 3,00
	Ganzzahl      : 12345
	gekürzt       : 12345
	erweitert     : 00012345
- tput for terminal control:
 - tput is a program (not builtin) and knows the terminal libraty terminfo (previously /etc/termcap). It contains many attributes for controlling the terminal
 - tput clear | tr '\033' 'X' ; echo -> X[HX[2J (\033 replaced by X)
 - echo -en '\033[H\033[2J' -> clears the screen -> works only for echo $TERM = xterm*
 - tput cols -> #columns; tput lines -> #lines; tput colors -> #colors supported by terminal; tput pairs -> color pairs
 - tput {bold, boldoff, blink, rev (inverse font), smul (underline), rmul (underline off), sgr0 (reload defaults)}
  - echo "Text wird `tput bold``tput rev``tput smul`Hervorgehoben`tput sgr0`"
  - echo "`tput setaf 2``tput setab 5`QASSEM" -> set background and forderground colors (argument 0..7)
  - tput clear -> clear screen; tput home -> move cursor to (0,0); tput cup n m; move cursor to (n,m)
  - tput dl1/il1 -> delete current line/add a new line at current line; tput dch1 -> delete one character at current position
- xxd: make a hexdump or do the reverse: echo ABCD | xxd -> "00000000: 4142 4344 0a                             ABCD."
- od: dump files in octal and other formats:
 - echo ABCD | od -> 0000000 041101 042103 000012
 - echo ABCD | od -c -> 0000000   A   B   C   D  \n
 - echo ABCD | od -x -> 0000000 4241 4443 (alignment?)
- 5.2) Inputs
 - read variable: store standard input (keyboard until pressing ENTER) into variable
 - read a b -> 'Qassem Abu\t\t Ahmad' -> a=Qassem  b=Abu Ahmad -> whitespaces replaced by one space
 - read -option variable: 
  - -n number, e.g. read -n 5 x -> QASSE -> x=QASSE -> no need to press enter to exit command -> after reading n-th char it will exit automatically
  - -s: silent -> dont show what is beeing typed, e.g. for passwords
  - -t s: wait s seconds for input. after a timeout the read commands returns error=1 and the script continue execution
 - read variable < zitat.txt: reading one line from file and store it in variable
 - WARNING: while read var < datei; -> this will always read the same line
  - Solution:
   - while read line; do ... done < datei, or
   - cat datei | while read line; do ... done -> nach jedem erneuten Schleifendurchlauf die Pipe geschlossen und die Variable somit verworfen wird
 - Heredoc (Here Document): command substitution is done
Command <<TEXT_MARKE
Heute ist `date`
TEXT_MARKE
 - Backslash before TEXT_MARKE or 'TEST_MARKE' will prevent command substitution, i.e. exactly Heute ist `date` is inserted to command's stdin
Command <<\TEXT_MARKE
Heute ist `date`
TEXT_MARKE
 - setting variable using heredoc
count=`cat <<TEXT_MARKE
\`ls -l | wc -l\`
TEXT_MARKE`
 - "<<- TEXT_MARKE" should remove leading TABs (not spaces). Thid did not work in my tests 
 - heredoc and read:
while read line; do...done <<TEXT_MARKE
line1
...
line_n
TEXT_MARKE
- The Variable IFS (Internal Field Separator):
 - echo -n "$IFS" | xxd -> 00000000: 2009 0a; 20 space; 09 tab; 0a newline
 - echo -n "$IFS" | od -c -> 0000000      \t  \n
 - BACKIFS="$IFS"; IFS=\; echo -n "$IFS" | od -c -> 0000000; read nachname vorname alter (input=Wolf;Jürgen;30)
 - IFS=: ; set $PATH; for path in "$@"; do echo "$path" done; IFS=$BACKIFS <-> echo $PATH | tr ':' '\n'
- read and Arrays (Bash and Korn-Shell only):
 - typeset -i i=0; while [ $i -lt 5 ]; do printf "Eingabe machen : "; read valarr[$i]; i=i+1; done -> for i < 5 -> echo ${valarr[$i]}
 - typeset -i i=0; while read vararray[$i]; do i=i+1; done < datei_zum_einlesen
- read string and store tokens in an array (depending on IFS)
read -a array <<TEXTMARKE
$variable
TEXTMARKE
- read -p "Ihr Vorname : " vorname (only bash)  <-> read name?"Ihr Name bitte: " (only Korn)
- Default-Variable for read: if no variable given to read -> stroe input in $REPLY
- Reading n characters (only Bash?): read -n 1 var -> presseing one char will store it in var and exit
- Reading n characters using dd:
# Terminal in den "rohen" Modus schalten, weil Terminal zeilengepuffert ist
stty raw -echo
# In Schleife überprüfen, ob 'q' gedrückt wurde
while [ "$char" != "q" ]
do
   char=`dd bs=1 count=1 2>/dev/null`
done
# Den "rohen" Modus wieder abschalten
stty -raw echo
- examples for dd (data duplicator https://linuxconfig.org/learning-linux-commands-dd):
 - dd if=$input_data of=$output_data [options] (https://linuxconfig.org/learning-linux-commands-dd)
  - dd if=/dev/urandom of=/dev/sda bs=4k: Fills the drive with random data
  - dd if=/dev/sda of=/dev/sdb bs=4096: Drive-to-drive duplication
  - dd if=/dev/zero of=/dev/sda bs=4k: Clean up a hard drive (may need to be repeated)
  - dd if=inputfile of=/dev/st0 bs=32k conv=sync: Copy from file to tape device
  - dd if=/dev/st0 of=outfile bs=32k conv=sync: The above, reversed
  - dd if=/dev/sda | hexdump -C | grep [^00]: Check if drive is really zeroed out
  - dd if=/dev/urandom of=/home/$user/hugefile bs=4096: Fills out a partition (careful with system partitions!)
  - ls -l myfile -> -rw-r--r-- 6703104 Oct 31 18:25 myfile -> dd if=/dev/urandom of=myfile bs=6703104 count=1: Scramble a file (maybe before deleting it)
- Catching ESCAPE-SEQUENCIES
 - Some buttons like ARROWN and Fn consists of a sequence of chars starting with \E (ESC=ASCII-27). This sequence might have variable lenth depending on terminal type and encoding
 - TERMINAL-ESCAPE-SEQUENCIES using infocmp -> ...cup=\E[%i%p1%d;%p2%dH, cuu=\E[%p1%dA, cuu1=\E[A,...
  - man 5 terminfo | grep cuu1 -> "cursor_up                 cuu1   up   up one line"
  - ARROW_UP=\E[A = ESC + [A
  - C\C++: if(read(STDIN_FILENO, &c, 1) > 0) if(c == 27) if(strcmp(buffer,"[A") == SUCCESS) -> ARROW_UP clicked
- Reading Passwords:
 - stty -echo; read password; stty echo -> turn off/on output
- 5.4) Redirection using exec: exec > file; exec >> file; exec 2> file; exec 2>> file; exec < file
 - echo "$0 wird ausgeführt" (output on screen); exec >ausgabe.txt (redirect all outputs to ausgabe.txt); val=`ls -l | wc -l`; echo "Im Verzeichnis $HOME befinden sich $val Dateien"; echo "Hier der Inhalt: "; ls -l
 - exec <data.dat; printf "%-15s %-15s %-8s\n" "Nachname" "Vorname" "Telefon"; printf "+%-15s+%-15s+%-8s\n" "--------" "-------" "-------"
   while read vorname nachname telefon; do printf " %-15s  %-15s  %-8d\n" $nachname $vorname $telefon; done
   - each loop will read 3 new tokens
- 5.5) File Descriptors (fd): an integer refering to an openned file. fds 0 stdin, 1 stdout, 2 stderr -> connected with the terminal tty
 -  echo example > file <=> echo example 1> file : redirect stdout to file
 - read x < file <=> read x 0< file : redirect stdin to file
 - echo "Hallo Welt auf stderr" >&2 <=> echo "Hallo Welt auf stderr" 1>&2 : redirect stdout to stderr
 - command <&fd : read from file or file descriptor
 - command >&fd : write to file or file descriptor
 - command >>&fd : append to file or file descriptor
 - User Defined File Descriptors (only from 3 until 9):
  - exec fd> destination; exec fd>> destination; exec fd< destination; releasing by exec fd>&-
  - exec 3> `tty`; echo "Hallo neuer Kanal" >&3; exec 3>&-; echo "Hallo neuer Kanal" >&3 -> bash: 3: Ungültiger Dateideskriptor
 - User-Defined fds are also usable in subshells
 - Using exec >&- without channel will close stdout. the same applies for fds 0 and 2
   REOPENING: exec 1> `tty`
 - Useful Applications:
  - read/write access posiotion is kept after each operation:
   - who > user.dat; read user1 <user.dat; read user2 <user.dat -> user2 contains the same line as user1 because the read access points always at the beginning
   - who > user.dat; exec 3< user.dat; read user1 <user.dat; read user2 <user.dat -> user1 contains line1 and user2 contains line2
  - Reading from multiple files:
   - exec 3< file1; exec 4< file2; exec 5< file3; exec 6< file4; while true; do read var1 <&3; do read var2 <&4; do read var3 <&5; do read var4 <&6; done
  - Reading from stdin and from a file:
   - exec 3< $1; while read line <&3; do echo $line; printf "Eine weitere Zeile einlesen? [j/n] : "; read; [ "$REPLY" = "n" ] && break; done
 - 5.5.2) Redirection with [n]<> file
  - open file for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified. If the file does not exist, it is created.
  - exec 3<> $1; while read line <&3; do echo $line; printf "Hier eine neue Zeile einfügen? [j/n] : "; read; [ "$REPLY" = "j" ] && break; done; printf "Bitte hier die neue Zeile eingeben : "; read; echo $REPLY >&3 -> Des Ruhmes Würdigkeit verliert an Wert,\nHier eine neue Zeile\nder selbst mit Lob sich ehrt.
- 5.6) Named Pipes: 
 - rarely used. same as normal pipe but it can be accessed be multiple processes
 - eine Konstruktion,welche die Ausgabe eines Prozesses als Eingabe zur Verfügung stellt. Bei normalen Pipes mussten die Prozesse vom selben Elternprozess abstammen (um an die Dateideskriptoren heranzukommen)
 - created by: mknod name p   or   mkfifo name -> e.g. mknod apipe p    prw-r--r--  1 tot users 0 2005–03–07 06:10 apipe (type p for named pipe)
   echo "Hallo User" > apipe; wait blockingly until data is read from another process. open o new terminal and type: tail -f apipe -> Hallo User
  - Prozess1, der in die Pipe schreibt, kann erst dann weiterarbeiten, wenn Prozess2 aus dieser Pipe liest, also ein weiterer Prozess die Leseseite einer Pipe öffnet (liest immer alles auf einmal)
 - name pipe file exists until it is deleted (exactly as normal files)
 - don't forget to adjust file permission if a different user should access the named pipe
 - Im Unterschied zu einer normalen Pipe, die in einem Schritt erzeugt wird (ein Inode-Eintrag, zwei Datei-Objekte und die Speicherseite) und sofort zum Lesen und Schreiben bereitsteht, werden die Named Pipes von den Prozessen im Userspace geöffnet und geschlossen. Dabei beachtet der Kernel, dass eine Pipe zum Lesen geöffnet ist, bevor etwas hineingeschrieben wird, sowie dass eine Pipe zum Schreiben geöffnet ist, bevor sie auch zum Lesen geöffnet wurde. Auf der Kernelebene ist dies in etwa dasselbe wie beim Erzeugen einer Gerätedatei (Device File).
 - echo a > apipe; in second terminal echo b > apipe; in third terminal cat apipe would print a\nb\n
 - after writing in (echo) or reading from (read) a named pipe, it will be directly closed. to write multiple lines ar to read linewise use loops:
  - while true; do echo 1; echo 2; echo 3; break; done > apipe
    i=1; while read line; do echo "line $i: $line"; i=$((i+1)); done < apipe
- 6.7) Menus with select (bash and korn shell only)
 - select variable in menu_points; do cmd1;...cmdn; done -> produces a numbered list of menu points. the user selects a number and the corresponding point is stored in variable. The corresponding number is stored in $REPLY. If user selects an invalid point -> variable="". After each selections all commands between do and done are executed. Then the user is asked to select again a number (endless loop exited by a exit/break or CTRL+D=EOF). PS3 is used as a prompt (usually is #). menu_points misht expads, i.e. b< using *-, ?, [], ``...
 - PS3="Ihre Wahl : "; select auswahl in Punkt1 Punkt2 Punkt3 Punkt4 Ende; do case "$auswahl" in
      Ende)  echo "Ende"; break ;;
        "")  echo "Ungültige Auswahl" ;;
         *)  echo "Sie haben $auswahl gewählt"
   esac
done
 - examples: select var in *.c *.sh *.txt; select var in `who | cut -c1–8 | grep -v $LOGNAME`; select var in `ls a*`
 -  PS3="Datei zum Editieren auswählen : " # Ein neues Auswahl-Prompt
    EDIT=vi # Hier den Editor Ihrer Wahl angeben
    select auswahl in * Ende; do
       case "$auswahl" in
          Ende)  echo "Ende" ; break ;;
            "")  echo "$REPLY: Ungültige Auswahl" ;;
             *)  [ -d "$auswahl" ] && \
                 echo "Verzeichnis kann nicht editiert werden" &&\
                 continue
                 $EDIT $auswahl
                 break ;;
       esac
    done 
 - Sub-Menus: in case statement write another select satement: A)  select auswahla in A1 A2 A3; do...
- 5.8) dialog und Xdialog (have same format, just replace dialog with xdialog. xdialog has mor features)
 - dialog --yesno [Text] [height] [width]: (height or width = 0 -> auto determined)
  - dialog --yesno "Möchten Sie wirklich abbrechen?" 0 0; antwort=$? (0=ja, 1=no); clear
 - [X]dialog --msgbox [Text] [Höhe] [Breite]: shows informational box
  - dialog --msgbox "Die Antwort war JA." 5 40
 - [X]dialog --infobox [Text] [Höhe] [Breite]: dialog --infobox "Dieser Vorgang kann ein wenig dauern" 5 50
 - [X]dialog --inputbox [Text] [Höhe] [Breite] [[Vorgabetext]]
  - name=`dialog --inputbox "Wie heißen Sie?" 0 0 "Jürgen" 3>&1 1>&2 2>&3`; dialog --clear; dialog --msgbox "Hallo $name, Willkommen bei $HOST!" 5 50; clear
  - 3>&1 1>&2 2>&3 -> Nachteil von dialog: Ergebnis wird hier immer auf die stderr statt auf die stdout erfolgt. Und um die Dialogausgabe zur weiteren Verarbeitung in eine Variable zu schreiben, müssen Sie ebenso vorgehen.
  - to understand --clear option see example:
   - dialog --begin 2 2 --yesno "" 0 0 --and-widget --begin 4 4 --yesno "" 0 0 --and-widget --begin 6 6 --yesno "" 0 0
     (Only the last widget is left visible)
     dialog --clear       --begin 2 2 --yesno "" 0 0 --and-widget --clear       --begin 4 4 --yesno "" 0 0 --and-widget --begin 6 6 --yesno "" 0 0
 - dialog --textbox "$0 (filename)" 0 0 -> shows $0 in a text box. we an scroll to all directions
 - [X]dialog --menu [Text] [Höhe] [Breite] [Menühöhe] [Tag1] [Eintrag1] ...
   os=`dialog --menu "Betriebssystem wählen" 0 0 0 "Linux" "" "BSD" "" "Solaris" "" 3>&1 1>&2 2>&3`; echo $os
    -> select from a menu
 - [X]dialog --checklist [Text] [Höhe] [Breite] [Listenhöhe] [Tag1] [Eintrag1] [Status1] ...: select multiple tags
   pizza=`dialog --checklist "Pizza mit ..." 0 0 4 Käse "" on Salami "" off Schinken "" off Thunfisch "" off 3>&1 1>&2 2>&3`; echo $pizza
   -> e.g pizza = "Käse Thunfisch"
 - [X]dialog --radiolist [Text] [Höhe] [Breite] [Listenhöhe] [Tag1] [Eintrag1] [Status1] ... -> select only one tag
   pizza=`dialog --radiolist "Pizza mit ..." 0 0 3 Salami "" off Schinken "" off Thunfisch "" off 3>&1 1>&2 2>&3`; echo $pizza
 - [X]dialog --gauge [Text] [Höhe] [Breite] [Prozent]
   (echo 10; sleep 1; echo 20; sleep 1; echo 30; sleep 1; echo 40; sleep 1; echo 50; sleep 1; echo "XXX"; echo "WE REACHED 100%") | dialog --title "Fortschrittszustand" --gauge "Starte Backup-Script" 8 30 10
  - gauge expect more info from stdin -> INT -> Percentage; echo "XXX" instructs gauge that a new text is coming
 - Verändern von Aussehen und Ausgabe: Aussehen und die Ausgabe beeinflussen:
  --title:	Eine Titelzeile für einen Dialog festlegen (Beschriftung für den oberen Rand)
  --backtitle:	Eine Titelzeile am Bildschirmrand festlegen (hierbei wird häufig der Scriptname verwendet, der zum jeweiligen Dialog gehört)
  --clear:	Dialog-Bildschirm löschen
- 5.9) Visualization of measurement data 2D and 3D. Examples in http://gnuplot.sourceforge.net/demo/ 
 - plot [x_min:x_max] [y_min:y_max] sin(x),cos(x),tan(x),x**2
 - Variables and Parameters: see 'help set' -> The `set` command can be used to set _lots_ of options.  No screen is drawn, however, until a `plot`, `splot`, or `replot` command is given.
 - set xlabel "X-ACHSE"; set ylabel "Y-ACHSE"; set xrange [0:4]; set yrange [-1:1]; plot sin(x)
 - Output Redirection: 'set terminal' shows all supported terminals
  - set output file.endung; set terminal png/postscript/latex/windows(x11)/PRN(printer, note that terminal must be set with the correct driver); plot sin(x) -> output saved into file.endung
  - '! bash-command': executes a bash command without exiting gnuplot
  - Variables: var=value; print var -> var_a=1+var*sqrt(2); print var_a
   - Pi=3.1415; set xrange [-2*Pi:2*Pi]; a=0.6; plot a*sin(x)
   - Defining Functions: func(x)=var*sin(x); var=0.5; plot func(x); var=0.6; plot func(x)
 - 5.9.7) Interpretation of data from files:
    - set xrange [0:60]; set yrange [0:40]; set xlabel "Monat"; set ylabel "Grad/Celcius"; set style data lp; set title "Temperatur-Daten 1999-2002"; plot "messdat.dat" using 1:2 t "1999", "messdat.dat" using 1:3 t "2000", "messdat.dat" using 1:4 t "2001", "messdat.dat" using 1:5 t "2002"
      using 1:2 -> use first  column for X-Achse and second column for Y-Achse
 - 5.9.8) replot:
  - instead of giving the previous settings again after changing the file data (columns) -> replot does it automatically for us
  - or, redirect current plot and save it in another format: set terminal postscript; set output "messdat.ps"; replot; ! ls *.ps -> messdat.ps
  - save "messdat.plt"; load "messdat.plt": store and load current plot (in gnuplot format)
  - The command test: shows you the setting plotted, i.e. you will see the setting of each line, such as color and thickness
 - 5.9.9) using gnuplot from scripts or bash
  - gnuplot messdat.plt: plots file and exits directly:
   - add pause -1  to last line and the plot will wait until pressing a key, or
   - gnuplot -persist messdat.plt
   - executing messdat.plt as a script: head -1 messdat.plt -> #!/usr/bin/gnuplot -persist
   - Using from shellscripts:
    - echo 'plot "messdat.dat" using 1:2 t "1999" with lp' | gnuplot -persist, or using HERE Document
    - FILE=messdat.dat; gnuplot -persist <<PLOT
    set xrange [0:6]
    ...
    plot "$FILE" using 1:2 t "1999".......
    PLOT
 - 5.9.10) Plot-Styles
  - set style data lp/steps: lp linepoints
  - Labels:
   - set label "string" at PointX,PointY: put a label at point (x,y) 
   - set title "string"
   - set linestyle 1 linetype 1 linewidth 1 pointtype 1;  // linetype e.g. color
     plot "messdat.dat" using 1:2 t "1999" with lp linestyle 1
   - set size Xval,Yval: scaling plot, e.g. set size 0.8,0.8 -> 80% of the original size
   - ...
   
- 6) Functions
 - funktions_name() { kommando1 ; kommando2 ; ... ; kommando_n ; } # before { must be at least one space, before } bust be ; or newline
 - Definition (Bash und Korn-Shell only): function funktions_name { kommando1 ; kommando2 ; ... ; kommando_n ; }
 - shell functions are exwcuted before the script itself (not in a sub-shell). shell functions are access/modify script variables, which are not yet defined
 - unset function -> deletes a function. Korn/Bash shells allow functions and variables to have the same name -> unset -f function will delete function and not the var
 - Export Functions: export -f function_name: Allgemein gibt es keine Möglichkeit, Shell-Funktionen zu exportieren. Ausnahme ist wieder die Bash.
  - Bourne-Shell und Korn-Shell hingegen können keine Funktionen exportieren. Umweg: ". file", file contains definition of function_name
  - Function Libraries .bib: loading by 'source lib.bib' or '. lib.bib'
 - Call Order: if there is a function which matches a name of a intern shell-command (builtin) or extern shell command (PATH) -> Call order:
  - 1) shell function, 2) builtin command, 3) extern shell command (PATH)
  - type command: type hallo -> hallo is a function. type echo -> echo is a shell builtin. type find -> find is /usr/bin/find
  - explicitly calling command using builtin or path-to-command: builtin echo "Hallo Welt". /bin/echo "Hallo Welt"
    Differencies between both echos: builtin echo --help , /bin/echo --help
  - Listing all functions: 
   - set: shows all variables and functions with their definition
   - typeset -f: shows all functions with their definition
   - typeset -F: shows all functions without their definition
 - 6.2) Calling Functions:
  - called functions must be defined before the callinf function
  - recursion: fakul() { value=$1; [ $((value)) -le 1 ] && { echo 1; return; }; echo $(($value * `fakul $value-1` )); }
    fakul $1
 - Function Parameters: given similar to normal scripts: functions_name arg1 arg2 arg3 ... arg_n
  - accessing params using: $1...$9 ${n}. $* $@ $# have same meaning as in scripts.only $0 is reserved for the script name
  - Die Parameter, die Sie an die Funktionen übergeben, haben nichts mit den Kommandozeilenparametern des Scripts zu tun, auch wenn eine Funktion nach demselben Schema arbeitet.
  - $FUNCNAME (Bash only): contains the function name
 - 6.4) Return Values: either using return integer, or by a global variable or by echo result and the main function (program) uses command substitution
  - return [n], 0 <= n <= 255, negative values also possible: if n/return n not used -> the reult of last executed command is returned
   - accessing returned value by $?
  - return with echo and command substitution: variable=`functions_name arg1 arg2 ... arg_n`
   - double() { val=`expr $1 \* 2`; echo $val; } ; val=`verdoppeln 25` ; echo "verdoppeln 25 = $val"
  - returning multiple values: double2() { val1=`expr $1 \* 2`; val2=`expr $2 \* 3`; echo $val1 $val2; }
  - Returning using local variables -> which are accessible in the entire script
   - double() { val=`expr $1 \* 2`; }; double 10; echo $val; -> 20
  - 6.4.4 Functions and exit: exit end the script immediately. function uses exit in case of critical error, such as missing important function argument
- 6.5) Local and Global Variables: In scripts there are only global varfiables and are defined only after their first usage.
 - To avoid that functions use the same global variable twice, it is recommended that each variabl in a function begins with (some letters of) the function name 
 - 6.5.1 Local Variables (Bash and Korn-Shell only): local var=value
  - var="ich bin global"; localtest() { local var="ich bin local"; echo $var; }; echo $var; localtest; echo $var; -> calling script -> ich bin global\nich bin local\nich bin global
  - local variables are also seen in sub functions, i.e., var="global"; f1() { local var="local"; f2; }; f2() { echo $var; }; f1; -> local
- 6.6) alias und unalias: alias name definition: defines an alias. unalias name: deletes an alias. alias: shows all aliases
 - e.g. alias xpwd="du -sh ." ; unalias xpwd ; alias sys="ps -ef | more"; type sys -> sys is aliased to `ps -ef`
 - aliases are only accessed for a use (due to security). Aliases are deleted after logging out.
 - define aliases in .bashrc if you want to access them always
- 6.7) Autoload (Korn-Shell only): loading only needed funtion from a library on need. autoload makes a not executable files from each function in FPATH -> faster than loads the entire library
 - FPATH="$FPATH:/pfad/zur/funktionsdatei"; export FPATH

- 7) Signals: used to control the processes.We ourself can specify how a process reacts on a signal, or we leave the reaction to the system itself
 - 7.1) Basics: Signals are asynchronous events that interrupts (from user level) a process -> used got interprocess communication by senging ints or MACROs
  - There are 3 Categories:
   - System signals: Hardware- und Systemfehler, ILL, TRAP, BUS, FPE, KILL, SEGV, XCPU, XFSZ, IO
   - Device signals: HUP (hang up), INT, PIPE, ALRM, CHLD, CONT, STOP, TTIN, TTOU, URG, WINCH, IO
   - User defined signals: QUIT, ABRT, USR1, USR2, TERM
  - kill l: shows all signal numbers and symbolic names
  - when an event occurrs -> event stored in Prozesstabelleneintrag. the kernel decides how to react on it when activating the process:
   - execute default routine, ot ignore signal, or let the user react on it.
  - 7.2) send signals: kill -SIGNAL PID [ PID ... ] -> SINGAL={number, signal name, signal name starting with SIG}
   - kill –9 1234 == kill -KILL 1234 == kill -SIGKILL 1234
   - if SIGNAL is not given -> default signal SIGTERM=15 is used: Programme, die SIGTERM abfangen, bieten meistens einen »Soft Shutdown« an.
   - It is recommended to try SIGTERM before SIGKILL
   - You can not send signals to processes of other users (except super users)
  - 7.3) Signal Trapping (fakh, masyadah): opposite of kill -> trap reacts on signals and prevets exiting shell scripts
   - trap 'kommando1; ... ; kommaond_n' Signal-Number: when signal number is received, the commands in single quotes are executed and then the shell will resume executing
   - trap 'echo SIGINT erhalten' 2; i=0; while [ $i -lt 5 ]; do echo "Bitte nicht stören!"; sleep 2; i=`expr $i + 1`; done # (Strg)+(C) or kill –SIGINT PID_von_trap1 -> executes echo SIGINT erhalten
   - Trapping multiple signals:
    - trap 'echo SIGINT erhalten' 2; trap 'echo SIGTERM erhalten' 15, or
    - trap 'echo Ein Signal (SIGINT/SIGTERM) erhalten' 2 15
   - Trapping SIGKILL/SIGSTOP is not supported
  - 7.3.1) Signal Handlers (Functions):
   - sighandler_INT() { printf "Habe das Signal SIGINT empfangen\nSoll das Script beendet werden (j/n) : "; read; if [[ $REPLY = "j" ]]; then echo "Bye!" exit 0; fi; }; trap 'sighandler_INT' 2;...
   - Verwenden Sie in der Korn-Shell innerhalb von Funktionen die trap-Anweisung, dann sind die mit ihr eingerichteten Signale nur innerhalb dieser Funktion gültig.
   - kill -HUP PID_of_dämon_oder_server: Konfiguration neu laden fuer Daemonen or sent to a process when its controlling terminal is closed. (It was originally designed to notify the process of a serial line drop.)
    - trap 'readconfig' 1; readconfig() { . aconfigfile; /*contains values for a,b,c*/ } a=1; b=2; c=3; while [ 1 ]; do echo "Werte (PID:$$)"; echo "a=$a"; echo "b=$b"; echo "c=$c"; sleep 5; done
  - 7.3.2) exiting loops with signals: trap 'break' 2; while [ 1 ]; do echo "$i. Schleifendurchlauf"; sleep 1; i=`expr $i + 1`; done; echo "Nach dem $i Schleifendurchlauf abgebrochen"
   - 7.3.3) Exiting Scripts with Signals -> Free ressources before exiting: trap 'rm atempfile.tmp ; exit 1' 2
   - 7.3.4) Catching Ending of Shell or Script (e.g. with command exit):
    - Ending a script: trap 'exithandler' 0 # exithandler must should not contains the exit command, because the script is exiting now
    - Ending a Shell: script.name=onexit{ echo "Alles erledigt – Shell mit ENTER beenden"; read} -> on console: trap '$SHELL $HOME/dasEnde' 0
    - Damit die Datei »onexit« mit wichtigen Hinweisen nach jedem Verlassen einer Shell dauerhaft zur Verfügung steht, sollten Sie die Zeile trap '$SHELL $HOME/dasEnde' 0 in die Datei .profile eintragen.
   - 7.3.5) Ignoring Signals: trap '' Signalnummer
   - 7.3.5) Reseting Signals: trap Signalnummer-List
   - trap -> shows signals which should be catched
   
- 8.1) Process Priorities:
 - Each process hat a priority, e.g. system process has a higher priority that a user process
 - Multitasking OS: 1 CPU can serve only on process at the same time -> multitasking. Scheduler assign each process a time slot. Moreover each process hat a priority
  - System process: has a higher priority, which can not be changed by users
  - Real time process: time critical processes -> has higher priority as time sharing processes
  - Time sharing: processes share CPU as fair as possible. each process take a time slot (size depends on #processes and CPU perfomance)
  - Each process has a priority.
  - In order to stay fair and consider priorities -> process priority is recomputed after each execution
  - Commands: nice/renice can affect the process priority. ps -l show NI (NICE) value. We can change process priority by setting -20 (highest) <= NI <= 19 (lowest) 
  - Commands starting in a shell take the same prio as the shell
  - renice PRIO PID: e.g. renice +10 1234 -> 1234: Old Priority: 0, new Priority: 10
   - setting a higher priority (even to original prio) need a root rights, i.e. su -c 'renice -5 1234'
- 8.2) Waing for other Processes:
 - wait PID: wait until PID ends -> wait returns the return values of PID. value 127 means -> process does not exist
 - wait (without PID): waits for all active child processes to end -> return value = 0
 - e.g.: sleep 10 & -> wait $!; echo $? -> https://phoenixnap.com/kb/bash-wait-command
- 8.3) background and foreground processes
 - cmd/script & -> execute cmd/script in background. If script need user input such as read-command -> script is stopped -> ps -l -> a stopped process has T (traced) -> 7249 pts/41   T      0:00 /bin/bash -> fg %1 (%job_specification)
- 8.4) Protecting background processes (nohup)
 - shell is closed -> SIHHUP=1 sent to all processes -> bg processes will be closed (not in SuSE 9.1!!!)
 - nohup cmd args & -> stdout/stderr redirected to nohup.out, if failed to $HOME/nohup.out, if failed -> error
  - return result 126: command could not be started. 127 -> command not found
  - same effect by using trap '' 1; cmd args
- 8.5) Subshells: ( kommando1 ; ... ; kommando_n ) or using new lines instead of ;
 - starts a subshell, and returns the result of the last executed command. the subshell copies all environment variables by value
- 8.6) Communication between Scripts
 - by exporting variables: all scripts will see the same variables
 - by passing as arguments $1...$9...${n}: in script1: ./script2 $a $b $c
 - by using temp files: e.g. one process writes in file and the other process reads from it
  - script1: IFS='\n'; for var in `ls -l`; do echo $var; done > file.tmp; ./script2
    script2: while read line; do echo $line; done < file.tmp
    Without redirection -> use pipe: ./script1 | ./script2
  - by returning data -> calling scripts use command substitution: script1: var=`./script2`; set $var; echo "$1; $2; $3". script2: echo var1=wert1; var2=wert2; var3=wert3; echo $var1 $var2 $var3
    another example script1: var=`./script2`; i=1; for wert in $var; do echo "$i: $wert"; i=`expr $i + 1`; done
    another example script1: ./script2 | while read wert; do for val in $wert; do echo "$val"; done ; done # linewise reading
 - by using a named pipe:
  - PipeServer: mknod meine_pipe p; while true; do read zeile < meine_pipe; echo $zeile; done
    Vorteil: Die anderen Scripts, die Daten in diese Pipe schicken, werden nicht blockiert, weil immer auf der anderen Seite des Rohrs der Server »PipeServer« darauf wartet.
 - 8.6.3) Synchronizing Scripts using signals:
  - FILE=tmpfile.tmp; rm $FILE; touch $FILE; while true; do if [ -r $FILE ]; then echo "Datei wird gelesen ..."; sleep 1; ./script_zum_Lesen; chmod 0200 $FILE; fi
                                                            if [ -w $FILE ]; then echo "Datei ist bereit zum Schreiben ..."; sleep 1; ./script_zum_Shreiben; chmod 0400 $FILE; fi; sleep 1; done
- 8.7) Job Management:
 - sleep 10 & -> [1] 5915 -> i.e. [JOB_NUMBER] PID
 - jobs: shows all background jobs
 - CTRL-Z stopping a foregrounf job (SIGSTOP) -> [1]+  Stopped (state)         du /
  - kill -SIGCONT %1 or kill -SIGCONT PID continues job 1
  - kill %1 == kill -SIGKILL %1 -> ends job 1
  - kill -SIGTERM %1 -> terminates job 1
  - bg %1: sends job 1 into background.  bg or bg %: send last stopped job (current job) into background.
- 8.8) Execution of scheduled scripts: e.g. for backups/ checking consistency, logging
 - Daemon (disk and execution monitors): Background process waiting for tasks to execute
 - Cron Daemon: define and delegate tasks to cron for execution. This is done in crontab. The PC must run at execution time. Some distributions use anacron to guarantee that the tasts are executed even if the PC is shut down
  - crond reads crontab in specific time intervals (usually each minute) and execute defined tasks. it is enough to define a task in crontab
  - cron task should not use stdin (read) and stdout. stdin/stdout should be redirected. The output is sent usually to crontab's owner
  - cron task should be careful using environment variables, because you don't know if these vars exist in the shell, which is started by crond
  -> crontab can contain env. vars -> shells started by crond use these env. vars.:
   - LOGNAME or USER = crontab's owner
   - HOME=LOGNAME/USER's home dir
   - PATH: be sure that it contains $PATH when cron task (script) is executed -> scripts should use absolute paths to avid problems with PATH var
   - if the cron task (script) want to know that it is in execution -> execute tty -s; assert echo $?==0 # -s := silent because cron tasks use no stdout/stdin
   - crontab format: 0-59 (minutes) 0-23 (hours) 1-31 (day) 1-12 (month) 0-7 (dayOfMonth 0=7=sunday) [User] (name, only for root) command -> 6/7 columns for normal user/root
   - * * * * * $HOME/meinscript -> each minute,  0 10–14 * * * $HOME/meinscript every day at 10,11,12,13,14 oclock,  0 10–12,16,20–23 * * * $HOME/meinscript every day at 10, 11, 12, 16, 20, 21, 22, 23 oclock
     0 */4 * * * $HOME/meinscript every daty at 0,4,8,12,16,20 oclock,  0 23 15 * 6 $HOME/meinscript (every 15. of each month AND every saturday) at 23 oclock
     0 23 * * 0–6/2 $HOME/meinscript jeden zweiten Tag um 23 UHr
   - crontab -e: edit cron file;    contab -l: list all cron jobs;    crontab -r: delete all cron jobs
- 8.9) Shell-Starter-Process and Shell-Profile-Data
 - interactive shell: like calling bash. Not interactive shell: e.g. like calling a script, or ( ... ) or command substitution. Login Shell: called directly after log in
 - system wide initialization files: in /etc or /etc/profile or sometimes in /usr/etc. Some programs pur their config giles in /usr/share/packet/xxxxrc (rc=read command)
  - after logging in  -> /etc/profile is executed -> editable only from admin. login start a shell (specified in /etc/passwd like HOME). This shell set env vars. usually calls /etc/profile more init files
 - user specific init files: in home director
 - Start of a login shell:
  - Bourne-Shell:set environment -> /etc/profile -> $HOME/.profile
  - Bash-Shell:set environment -> /etc/profile -> $HOME/.bash_profile, if not found -> $HOME/.bash_login, if not found -> $HOME/.profile
  - Korn-Shell:set environment -> /etc/profile -> $HOME/.profile -> $ENV (usually $HOME/.kshrc)
   - .kshrc contains aliases/functions which can not be exported
 - Start of a not login shell: (remeber: aliases and functions can not be exported)
  - Korn-Shell: $ENV=.kshrc is executed
  - Bash-Shell: - interactive mode (e.g. calling bash): ~/.bashrc is executed
                - interactive mode (e.g. calling a script): $BASH_ENV is executed (if exists -> default ~/.bashrc)
  - Bourne-Shell: nothing
 - Exceptions: Starting subshells by ( ... ) or command substitution or calling a script after a point (e.g. source .bashrc or '. ./bashrc'): nothing is executed -> only an exact copy of environment is copied
 - More for Bash:
  - $HOME/.bash_logout: called when ending/logging out -> should free ressources
  - /etc/inputrc:	In dieser Datei wird die systemweite Vorbelegung der Tastatur für die Bash und andere Programme definiert, welche die C-Funktion readline zum Lesen der Eingabe verwenden. Veränderungen sind dem Systemadministrator (root) vorbehalten.
  - $HOME/.inputrc:	Wie /etc/inputrc, nur dass hier der normale Benutzer eigene Einstellungen vornehmen darf.
- 8.10) Executing Shell Scripts:
 - (./script or bash script) executes script in a subshell. The current shell is blocked until ending 
 - (./script& or bash script&) executes script in a subshell. The current shell is not blocked
 - (. ./script or source ./script) executes script in context of the caller shell
 - There are 3 Phases for script execution:
  - Syntax Checking: the script is read line by line and is checked for syntax
  - Expansion: Aliases- und Tilde-Expansion, command substitution, Variable-Interpolation, Computations (nur Bash und Korn-Shell) and file expasions
  - Command Execution: Execution Order: shell builtin commands (shell functions), Functions, extern commands (in PATH) or binary command or schell scripts
- 8.11) Optimizing Shell Scripts (Advices): speed up 2x until 10x
 - try to use builtin commands
 - use bash/korn shells because they have more builtin commands
 - use always the simplest version of a command (due to portability)
 - use fast commands: e.g. cat is 10x faster than reading with awk and 100x faster than read command
 - avoid reading big data with read command (specially in a loop). read is useful for user input and reading small files -> use cat, grep, sed or awk
 - avoid working with big files: extract important data using grep/sed/awk and save them in tmp file for later work
 - avoid using awk in loops and thus starting awk in each iteration -> write awk script and thus starting awk only once
- 9) Useful Functions:
 - 9.1) eval command line: Useful for executing commands stored in a variable -> used in scripts where commands are known in run time
  . eval ls -l | sort -r: same as without eval -> eval is not useful here
  - LSSORT="ls -l | sort -r"; executing set -x; $LSSORT -> + ls -l '|' sort -r \n ls: |/sort: Datei oder Verzeichnis nicht gefunden
    | and sort are considered arguments for command ls -> ls -l '|' sort -r needs a second evaluation. This is what eval does
  - eval $LSSORT: works as expected
  - example: while true; do printf "Kommando(s) : "; read; eval $REPLY; done -> executes commands read by user
  - Another good reason to use eval is the indirect access on variables:
   - Mo=backup1; Di=backup2;...So=backup7; tag=`date +"%a"` ; eval backup=\$$tag; echo "Heute wird das Backup-Script $backup ausgeführt"
     eval \$$tag: 2 iterations: \$$tag -> $Mi -> backup3
 - 9.2) xargs
  - cmd1 xargs cmd2: call cmd3 with the arguments sent by cmd1 over stdout
  - for var in `find . -name "*.tmp"`; do rm $var; done -> bad because rm is called for each file
  - find . -name "*.tmp" -exec rm {} \; -> bad because rm is called for each file
  - find . -name "*.tmp" -print | xargs rm -> good because rm is called only once for a list of file for deletion.
    Problem here: Files containing a space or a new line will not be deleted -> use find -print0 and xargs -0
   - find -print:  found files are separated by \n
   - find -print0: found files are separated by \0
  - find . -name "*.tmp" -print0 | xargs -0 rm: argument list are separated by \0. xargs -0: separates arguments by \0
  - if cmd2 expects more than one param such as "mv file dst_folder" -> use place holder {}: xargs -0 mv {} $HOME/backups
 - 9.3) dirname and basename: basename filename [Suffix] / dirname  filename
  - basename $HOME/Kap005graf.zip -> Kap005graf.zip
  - dirname $HOME/Kap005graf.zip -> /home/qahmad
  - basename $HOME/Kap005graf.zip .zip -> Kap005graf . basename $HOME/meinText.txt .txt -> meinText
 - 9.4) umask (file mode creation mask): reduces rights for user, group and other by: access rights on creating file - umask
  - umasks -> prints mask ; umask xyz -> sets umask to xyz -> only valid for the current shell session
  - usually files/dirs are created with access rights rw-rw-rw/rwxrwxrwx (octal 666/777). umask is 0002 (ubuntu, first 0 means: this is an octal number)
    666 - 002 = 664 -> i.e. files newly created will have rw-rw-r-- / 777 - 002 = 775 -> i.e. dirs bewly created will hav rwxrwxr-x
  - umask is set in /etc/login.defs (ubuntu) /etc/login.conf (FreeBSD) or in /etc/profile or ~/.bashrc
 - 9.5) ulimit [Options] [n]: builtin command: print or set a limit for a ressource
 - Option -H: A hard limit can only be raised by root (any process can lower it). So it is useful for security: a non-root process cannot overstep a hard limit.
              This will useful to mitigate DOS attacks -> set hard limits in /etc/profile
 - Option -S: A soft limit can be changed by the process at any time. So it's convenient as long as processes cooperate, but no good for security
 - ulimit -a
    core file size          (blocks, -c) 0            Maximale Größe der Speicherabzüge (core-File)
    data seg size           (kbytes, -d) unlimited    Maximale Größe eines Datensegments oder Heaps in Kilobyte
    scheduling priority             (-e) 0
    file size               (blocks, -f) unlimited    Maximale Anzahl an Dateien (Standardoption)
    pending signals                 (-i) 30384
    max locked memory       (kbytes, -l) 65536
    max memory size         (kbytes, -m) unlimited    Maximale Größe des physischen Speichers in Kilobyte (Bash und Korn-Shell only)
    open files                      (-n) 1024         Maximale Anzahl Filedeskriptoren i.e. open files (plus 1)
    pipe size            (512 bytes, -p) 8            Größe des Pipe-Puffers (Bash und Korn-Shell only, meistens 512 Bytes)
    POSIX message queues     (bytes, -q) 819200
    real-time priority              (-r) 0
    stack size              (kbytes, -s) 8192         Maximale Größe eines Stacksegments in Kilobyte
    cpu time               (seconds, -t) unlimited    Maximale CPU-Zeit in Sekunden
    max user processes              (-u) 30384        Maximale Anzahl von User-Prozessen
    virtual memory          (kbytes, -v) unlimited    Maximale Größe des virtuellen Speichers in Kilobyte
    file locks                      (-x) unlimited
 - 9.6) time command: prints execution time:
  - time sleep 3
      real    0m3.029s: execution time from start until end
      user    0m0.002s: execution time spent in user mode
      sys     0m0.002s: execution time spent in kernel mode (CPU-Time/Hard-Disc/System-Calls)
 - 9.7) typset [option] [variable] [=wert]: defines variable property (bash has only the equivalent command 'declare')
  - typeset -i var=1 (defines integer variable) ; typeset +i var -> var is not integer any more
      Option	Bash	ksh	Bedeutung
      A	      X		      Array
      I	      X	    x	  Integer-Variable
      R	      X	    x	  Konstante (readonly-Variable)
      X	      X	    x	  Variable exportieren
      F	      X	    x	  Zeigt Funktionen mit ihrer Definition an
      fx	    X	    x	  Exportiert eine Funktion
      +f		        x	  Zeigt Funktionen ohne ihre Definition an
      F	      X		      Zeigt Funktionen ohne ihre Definition an
      fu		        x	  Deklariert Funktionen im Autoload-Mechanismus
      l		          x	  Inhalt von Variablen in Kleinbuchstaben umwandeln.
      u		          x	  Inhalt von Variablen in Großbuchstaben umwandeln.
      Ln		        x	  Linksbündige Variable der Länge n
      Rn		        x	  Rechtsbündige Variable der Länge n
      Zn		        x	  Rechtsbündige Variable der Länge n. Leerer Raum wird mit Nullen gefüllt.
- 10) Seaching Failures and Debugging
 - Constants: Capital Letters (typeset -R)
 - Variables: Small capitals.
  - Function variables should be preceeded with function name or at least with some letters of the function e.g. func_x...
 - comment code
 - write only one command in a line -> this makes debugging easier, because on failure the line number is showed
 - indent code: ane make it more readable
 - 10.3) Searching Failures:
  - 10.3.1) Tracing with set -x: activate tracing in current shell and sub-shells
   - bash -x script or she-bang line=#!/usr/bin/bash -x
   - set .x in the script itself and not in the shell before executing the script because you will not see enogh traces
   - the number of + correspons to the nesting level, e.g. set -x; datum=`date` -> +./script1\n+++ date\n++ datum=Fr Apr  1 10:26:25 CEST 2005
 - 10.3.2) DEBUG und ERR (Korn only)-Signal: ERR is not documented in bash, but it should work. But $ERRNO does not exist in bash
  - DEBUG signal is sent after each expression -> trap it and debug
  - trap 'printf "$LINENO :-> " ; read line ; eval $line' DEBUG
  - to print the command beside $LINENO use the following beautiful technique:
   - debugging() { printf "STOP > "; while true; do read line; [ "$line" = "" ] && break; eval $line; printf " > "; done; }
     typeset -i index=1; while read zeile[$index]; do index=index+1; done<$0;
     trap 'echo "${zeile[$LINENO]}" ; debugging' DEBUG
    - Korn: error_handling() { echo "Fehler: $ERRNO Zeile: $LINENO"; printf "Beenden (j/n) : " ; read; [ "$REPLY" = "j" ] && exit 1; } 
      trap 'error_handling' ERR
      echo "Testen des ERR-Signals"; cat > /etc/profile; echo "Nach dem Testen des ERR-Signals"
 - 10.3.3) Variables and Checking Syntax: -u option -> bash -u ./script or set-u in script
  - set -u; var1=100; echo $var1 $var2 -> ./aunboundvar: line 7: var2: unbound variable
  - set -n -> only check for syntax errors e.g. bash -n ./script
 - 10.3.4) debugging using echos and readline and by redirecting unneeded outputs to /dev/null
  echo "Ausgabe1"; exec 1>/dev/null; func1; exec 1>`tty`; echo "Ausgabe2"
 - 10.3.5) Debugging-Tools e.g. : patched bash for debugging -> http://bashdb.sourceforge.net/
- 11) grep: Global search for a Regular Expression and Print out matched lines
 - egrep but not grep: + / ? / |. Moreover sames RegExes are written in egrep without a backslash e.g. () and not \(\)
 - 11.1) POSIX-RE:
  - [A-Z_a-z] , [^a-f] none of those chars.\d [0–9], \D [^0–9], \w	a char/num/_ [a–zA–Z_0–9], \W [^a–zA–Z_0–9], \s	Whitespace [ \f\n\r\t\v], \S [^\f\n\r\t\v]
  - ? 0 or 1, + at least one, * 0 or more, {min,} min times or more, {min,max} between min and max inclusive, {n} exactly n times
  - ^ line begin, $ line end, \b	word begin or end, \B not word begin or end, \<	word begin, \> word end
  - groups: s/\(string1\) \(string2\) \(string3\)/\3 \2 \1/g
  - grep word/words_including_white_space file_list -> return 0 if found, 1 if not found, 2 if file not found
  - grep word < input; or command | grep word
  - RegEx: ^ line begin/ $ line end/ ^$ empty line/ ./ */ .*/ []/ [^]/ \< / \> / \<\> / \(...\) / x\{m\} / x\{m\,} / x\{m,n\}
  - grep options:
   - -n print #line / -n if n is 1,2... print matched line +/-n lines, e.g. -1 prints matched line + prev./next line
   - -A n print matched line + n next lines / -B n print matched line + n prev. lines / -c print #matches / -h suppress filename, i.e. don't print it
   - -i case insensitive / -l print only file names that includes a match / -q return 0 if match is found, otherwise 1 (there r no outputs)
   - -s suppress failure outputs, i.e. when file does not exist / -v print all lines that do not match RegEx / -w look for complete words
 - 11.2)
  - egrep (extended grep): understands more regular expressions than grep. same as "grep -E regex file". E.g. egrep 'Colombo|Columbu|Col' mrolymia.dat
  - fgrep (fixed/fast grep): understands less regular expressions than grep -> faster. used only with strings, not regex
  - rgrep (recursive grep): loops over all sub folders, e.g. grep regex */*



- 14.2) File-Oriented Commands
 - bzcat/zcat: cat bzip2/gzip compressed files without uncompressing them -> uncompress files and send output to stdout while the compressed files are left intact
  - zless/zmore
 - cat file; cat file | command; cat file_part1 file_part2 > entire_file; cat > file: write from stdin (keyboard) in file
 - chgrp [-R] group file/directory: change file.group. only owner/root can change the group. Moreover owner must belong to the new group
 - chmod [-r]: chmod 755 file; chmode [uga][+-][rwx] file. Special Bits: SUID=4000; SGUID=2000 oder Sticky=1000 -> e.g. chmod 4744 file
 - chown user[:group] file1 file2
 - sum (CRC, old not recommended command)/cksum (CRC, POSIX.2-Standard)/md5sum files: cd /bin; md5 `ls -R /bin` | md5
 - cmp out.txt textfile.txt -> out.txt textfile.txt differieren: Byte 52, Zeile 3 -> print line and first different byte in both files
 - comm [-123] file1 file2: compare 2 sorted files. print lines only in file1 on left, lines only in file2 prepended with 1 tab, common lines prepended with 2 tabs
                            The options -1/-12/-13/-123... will not print the 1st/2nd/3rd column
 - cp file newfile; cp -r dir newdir; cp file1 file2 file3 dir	; cp –p file newfile -> newfile gets same owner/access rights and timestamp
 - csplit [OPTION]... FILE PATTERN...: splitting based on context into files xx00 xx01... and output byte count of each file
  - https://www.golinuxcloud.com/csplit-split-command-examples-linux-unix/
  - csplit -k --elide-empty-files csplit1.txt '/^}/+2' "{*}": split by pattern ^} -> split each bash function into a file
   - --elide-empty-files: ignore empty files
   - +2: add line with found pattern and the next line
   - {*}: repeat the previous pattern as many times as possible
   - -k: without -k no xx* files are created because there is no line after the last '}' and an error is printed out. with -k the files are created even if there is a failure
  - csplit Kapitel20.txt /Section 1/ /Section 2/ /Section 3/: split into 4 files, from begin until section1, section1-section2, section2-section3, section3-end
  - csplit -f section Kapitel20.txt 20 40: split into 3 files section00 (lines 1 until 20), section01 (lines 21 until 40), sendtion02 (lines 40 until end)
  - csplit -k /var/spool/mail/$LOGNAME /^From / {100}: each email starts with 'From ' -> split into files xx00...xx99
 - cut -c5/c5-10/c-10/c5/c1,3,5 file: cut characters
 - cut -d\; -f1,3 file: -d for delimiter   -f for field -> cut the first and the third columns
 - diff file1.txt file2.txt:   2a3 (append): new line added between line2 and line 3.    2c2 (changed)    2d1 (deleted)
 - diff3 file1 file2 file3: compares 3 files -> ==== all files are different.   ====[123] file[123] is defferent
 - expand -3 file: replace tabs with 3 spaces. removing tabs not possible, i.e. expand -0 returns an error -> use tr instead
 - file filename: analyzes the file content
 - find [Verzeichnis] [-Option ...] [-Test ...] [-Action... (default -print).]
  - find $HOME -print: find /dokus -name kapitel -print
  - find /dokus /usr -name 'kap*' -user qahmad -print
  - find / -type d -name 'dok*' -print
  - find / -size 0 -ok rm {} \; : look for empty files and delete them (-ok delete without prompting/asking user)
  - find / -mtime -7 -print: all files modified in the last 7 days  
 - fold [OPTION]... [FILE]...: wrap each input line to fit in specified width (default width 80)
  - fold -50 Kap003.txt : width=50, this will split words at line end and continue them in the next line -> use -s to suppress this behaviour
  - fold -s -50 Kap003.txt
  - use case: fold -s –72 text.txt | mail -s "Betreff" name@host.de
 - head -5 file
 - less: reads from stdin and shows input linewise. (H) for help
 - ln: when creating a file, an entry in the directory refers to an inode, access rights, filetype and #used-blocks.
       ln filea file_new: creates an entry in the directoy and refers to an existing inode -> hard link
       ln -s file file_new create a symbolic kink
  - ls
  - more: same as less, but less has more features
  - mv file filenew: rename
  - mv file dir: move file in directory
  - mv dir dirnew: move dir in dirnew
 - nl: print files with line numbers -> ls | nl -w3 -s') ' -> '  1) abc'
 - od [-h (hex) -c (ASCII)] file: print file in octal (default)/hexadecimal/ascii -> 0000000 064546 062554...
 - paste: opposite of cut - paste -d\; namen.txt nummer.txt > zusammen.txt ---> Qassem;+97246...
 - pcat: cat compressed files without uncompressing them
 - rm file; rm dir (empty); rm -r dir (recursive); rm -rf dir (don't show warnings)
 - sort -n (nummerical) -f (case insensitive) -r (reverse) -nr(num. reverse) -c (tests if a file is sorted) -u (uniq)
 - split - split a file into pieces -> file names starts with xx ( similar to csplit)
  - split -50 kommandos.txt [prefix, default is xx]; split 50 linewise, default is 1000 line
  - recovering original file by: for file in `ls x* | sort`; do cat $file >> new.txt; done
 - tac: reverse cat
 - tail -5 file; tail +100 file: prints file from line 100 till end. 
 - tail -r file == tac file
 - tail -f (follow) file
 - tee: duplicate output -> ls | tee file
 - touch file: set access time and modification time to current time. create file if does not exist
  - touch -a: update only access time
  - touch -c: do not create file if does not exist
  - touch -m: update only modification time
 - tr str1 str2 file: replace str1 by str2 -> tr \t "  " file
 - type name: classifies how theshell interprets the name (alias, builtin(shell function), file or script)
  - type ls echo ./hallo -> ls is aliased to `/bin/ls $LS_OPTIONS'\necho is a shell builtin\n./hallo is ./hallo 
 - umask – changing/showing file creation mask
 - uniq: print duplicate lines of sorted files only once
 - unix2dos fileunix filedos (text files)
 - dos2unix filedos fileunix (text files)
 - wc: show #lines #words #chars
 - whereis [-b only binary files] [-m only manual files] file: search file in important dirs such as PASH and manual directores /usr/share/man...
  - faster than find but not adequate
- 14.3) Directorey-Oriented Commands
 - dirname $HOME/Kap005graf.zip -> /home/qahmad
 - basename $HOME/Kap005graf.zip -> Kap005graf.zip
 - basename $HOME/Kap005graf.zip .zip
 - cd
 - mkdir -m 600 mydir; -m access rights
 - mkdir -p dir1/dir2/dir3; creates dir1/dir2/dir3 event if dir1/dir2 are not found
 - pwd
 - rmdir dir; same as rm -r dir. Difference: rm -r cannot delete dirs without execute access right, but rmdir can do it
- 14.4) User and Group Management
 - exit/logout/CTRL+D
 - groupadd [-g GID] group-name: add a new group, if GID is not given, the system generates it automatically (monoton increasing). GID can be changed by groupmod
 - groupmod [-g newGID] group-name
 - groupdel gruppenname
 - groups [OPTION]... [USERNAME (default=current user)]: print the groups a user is in. if USERNAME is not given, the current user is assumed
 - id [OPTION]... [USER (default=current user)] - print real and effective user and group IDs
 - last [options] [username...] [tty...] - show a listing of last logged in users (from /var/log/wtmp)
 - lastb [options] [username...] [tty...] - same as last, except that by default it shows a log of the /var/log/btmp file, which contains all the bad login attempts.
 - logname [OPTION] - print user´s login name, which is stored in /var/run/utmp by getty (you should be logged in with in a real terminal, in xterm you will get nothing)
 - newgrp [group default=standard droup in /etc/passwd] - log in to a new group (in a new shell session). e.g. touch temp; ls -l temp -> the new group is see in the group column.
 - passwd: change password in /etc/passwd of current user (-rwsr-xr-x 1 root root 68208 Jul 15  2021 /usr/bin/passwd). The SUID bit is set, this allows current user to change his password, although /usr/bin/passwd's owner is root. Damit hat der Anwender für kurze Zeit root-Rechte und kann somit sein Passwort ändern und darf in die Datei schreiben. Alle Passwörter darf nur root verändern.
 - passwd user: change password in /etc/passwd of user. MUST be executed by root
   options only for root: -l user: lock user;  -f user: force user to change his password; -d user: delete user's password -> login without password
 - useradd -u 1235 -c "Test User" -s /bin/bash -d /home/qzaiad qzaiad; -u==UID  -c==comment  -s==shell  -d==home directory (adduser does not create home directory)
 - useradd-s /bin/bash -d /home/qzaiad -m -k SKELETON_DIR qzaiad; -m creates home dir if doesnnot exist. -k copy files and dirs from SKELETON_DIR to home dir
  -after creating a user using useradd -> call passwd USER to set a password
 - usermod usermod -u 1235 -c "Test User" -s /bin/bash -d /home/testdir testuser: modify user propoerties
 - userdel user -> deletes user. It also removes all user's cron jobs
 - userdel -r user -> Files in the user's home directory will be removed along with the home directory itself and the user's mail spool.
 - who - show who is logged on
  - qahmad   :0 (terminal)           2022-07-06 16:13 (:0)
 - whoami - print effective userid, who is currently logged it -> qahmad
- 14.5) Program and Process Management
 - at: execute a command at a specific time, even if user is not logged in
  - at 2130 -f myscript (21:30); at 2200 apr 2 -f myscript (2. April at 22:00); Each task is queued in at-Queue (atq);
  - at -l -> lists all queued tasks;    at -l 33 list order no. 33;     at -d 33 -> delete order 33
 - batch (needs at daempn): executes a command sometime later (when cpu is not busy,  user is not logged in)
  - batch \n warning: commands will be executed using /bin/sh \n at> ls -l \n at> ./myscript \n at> sleep 1 \n at> (Strg)+(D) \n job 1 at 2005–04–21 23:30
 - bg/fg/jobs/cron/crontab/kill/nohup: see above
 - killall: same sa kill but takes a job name as a parameter (not PID)
  - sleep 60&; killall sleep -> ends all jobs called sleep
  - killall -l: lists all supported signals (the signal name is given without SIG prepended)
 - nice [-n, -20<=n<=20, default=10] command [arguments]: executes a command with a lower priority (usually cmds executed in background)
  - only root is allowed to start jobs with a prio higher than 0, i.e. -20<n<=0
  - nice find / -name document -print > /home/tmp/find.txt & (ps -l shows the prio 10 under colun NI)
 - renice: modify prio of already startet processes
  - comfortabler use top + R + value
 - ps: shows process information
  - ps: shows all processes started in this terminal
  - ps -e: shows all processes.     ps -f: shows all informations (all columns)    ----> ps -ef
  - ps -ef | grep kamix | awk '{ print $2; exit }'
 - pgrep process_name: shows all PIDs of all processes called process_name
 - pstree: show procsess hirarchy as a tree
  - pstree PID/user: shows all PID's user's processes as a tree
 - sleep time in seconds
 - su (Switch User): changes current user without relogin
 - sudo
 - time cmd: meassures exection time. see above
 - top: shows processes sored according to cpu usage. K: kill , R: Renice
- 14.6) Storage Information:
 - df [OPTION]... [FILE]...: report file system disk space usage
  - df: shows info about all mounted filesystems -> Filesystem                   Size  Used Avail Use% Mounted on
  - df path: shows info about filesystem containing path
      Filesystem                   Size  Used Avail Use% Mounted on
      /dev/mapper/ubuntu--vg-root  249G  214G   23G  91% /
  - df -H: shows human readyble info
 - du [OPTION]... [FILE]...: estimate file space usage -> shows used space in kilobytes-blocks of each file/directory recursively
  - du -b/k/m/g/h (bytes/kilobytes..../human-readable)
  - du -sh /home: summerized and human readable
  - du --max-depth=1 -m /home
 - free - Display amount of free and used memory/swap in the system
- 14.7) Filesystem Commands
 - badblocks - search a device for bad blocks
  - badblocks [-options] device-file [startblock]
   device-file: e.g. /dev/hda1 first hard desk,  /dev/fd0 floppy disk (1,44MB)
  - badblocks -s -o block.log /dev/fd0 1440: -s shows progress,  -o file: writes defect blocks in file (for later use by other programs)
 - cfdisk: partioning of hard disks. /dev/hda /dev/hdb==first/second IDE-hard-disk, /dev/sda /dev/sdb==first/second SCSI-hard-disk...
 - dd (data duplication):
  - ibs=BYTES: read up to BYTES bytes at a time (default: 512) -> size of input buffer
  - obs=BYTES: write BYTES bytes at a time (default: 512) -> size of output buffer
  - bs=BYTES: read and write up to BYTES bytes at a time (default: 512); overrides ibs and obs
  - count=N: copy only N input blocks
  - cbs=BYTES: convert BYTES bytes at a time
  - skip=N: skip N ibs-sized blocks at start of input
  - seek=N: skip N obs-sized blocks at start of output
  - conv={ascii,ebcdic,ibm,block,unblock,lcase,ucase,swab,noerror,sync}: convert the file as per the comma separated symbol list
   - block: pad newline-terminated records with spaces to cbs-size
   - unblock: replace trailing spaces in cbs-size records with newline
   - swab: swap every pair of input bytes
   - noerror: continue after read errors (ignore errors)
   - sync: pad every input block with NULs to ibs-size; when used with block or unblock, pad with spaces rather than NULs
  - if: input file. Default==stdin
  - of: output file. Default==stdout
   - dd if=/dev/urandom bs=4k count=1 -> 4096 bytes (4,1 kB, 4,0 KiB) copied, 0,000383205 s, 10,7 MB/s
   - dd if=/dev/urandom bs=4k count=2-> 8192 bytes (8,2 kB, 8,0 KiB) copied, 0,00127206 s, 6,4 MB/s
   - dd if=/dev/hda bs=512 count=1: print bootsector of first ide hard disk
   - dd if=/vmlinuz of=/dev/fd0: copy kernel in the first sector of the disket -> should be used as bootable disk
   - dd if=/dev/hda of=/dev/hdc: clone first HD of master IDE controller into hdc
 - ddrescue/dd_rescue: Data recovery tool that reads data from damaged block devices.
  - using a damaged device (e.g. by dd) might cause more damages to the device, so we should be careful using the device
  - ddrescue {{/dev/sdb}} {{path/to/image.dd}} {{path/to/log.txt}}: Take an image of a device, creating a log file
  - ddrescue --force --no-scrape {{/dev/sdX}} {{/dev/sdY}} {{path/to/log.txt}}: Clone Disk A to Disk B, creating a log file
 - dumpe2fs - dump ext2/ext3/ext4 filesystem information
  - dumpe2fs -b /dev/hda6: dump blocks marked as bad
 - e2fsck device/partiotion - check/repair a Linux ext2/ext3/ext4 file system
  - Files with Inodes that do not belong to any directoy (not marked in any dir.) are restored in lost+found dir. and can be repaired.
  - Exit Codes: - 0: success; - 1: failure found and repaired; - 2: severe failure dounf and repaired -> system should be restarted; - 4: failure found but could not be repaired
   - 8: failure in the command execution; - 16: wrong use of e2fsck; - 128: failure in the shared libs
  - Options: -p fix failuires without asking user.  -c search filesystem for bad blocks.  -f force filesystem check, even if kernel marked it as OK (valid flag is set)
 - fdformat - low-level format a floppy disk -> write disk with empty blocks
  - mkfs/mk2fs/mkreiserfs -> make file system
 - fdisk - manipulate disk partition table
  - not comfortable as cfdisk -> splits/adds/deletes/changes partition -> controlled by pressing letters for executing options
  - can also be used as a CLI command: useful when installing same OS on multiple HDs. Install linux on one HD, make image by dd, boot on other HDs e.g. by using damnsmall-Linux, execute script that make partiotions and fomats them by fdisk, copy image to HS by dd, configure Network
  - fdisk -l: shows all partiotions
  - fdisk /dev/hda: called when we want to partiotion HD /dev/hda
  - keyboard shortcuts:
   - b modify bsd disklabel/d delete part./l shows known filesystem types/m show menu with all commands/n new partition/p print partition table/q quit without save/t change fs type/u change unit/v verify fs table/W save and exit/X more options for experts
 - fsck - check and repair a Linux filesystem -> calls the right executable for the fs, e.g. fsck.ext2, fsck.minix, reiserfsck...
  - fsck detects fs type by options or by partition table
  - Options: -a automatic repair/ -A check all fs in /etc/fstab
  - Exit-Code: 0 no error/ 1 error in fs found and repaired/ 2 fatal error in fs found and fixed -> restart/ 4 found failuire but couold not fix/ 8 failure in executing fsch/ 16 fsch used wrongly/ 128 failure in shared libs
  - DO NOT execute fsck on reaonly-mode fs, because fsch can fix fs and change it -> fsch will crash in this case
  - fsck usually started on after each x-th boot or after a failure or crash
 - mkfs - build a Linux filesystem -> calls the right executable for the mkfs
  - Exit-Code: 0 no error/ 8 failure in executing mkfs/ 16 fsch used wrongly
  - Options: -t specify fs type....
 - mkswap [options] device [size]: set up a Linux swap area. swap partition/file activated by swapon
  - make a swap partition/file. Usually it is done on setting up the system, so no need to use it.
  - dd bs=1024 if=/dev/zero of=/tmp/myswap count=4096 (initialize 4MByte swap file with zeros); mkswap -c /tmp/myswap 4096; sync; swapon /tmp/myswap
  - note: swap file is much slower than swap partition. so create swap file only if there no place on HD for a new partition
  - note: he new swap file/partition is managed by the OS, not by you
 - mount/umount : mount/unmount
  - mount: show all mounted fs listed in /etc/mtab
  - mount /dev/fd0: mount disk fd0 (an entry must exist in /etc/fstab, otherwise write it as next line)
  - mount /dev/hda9 /home/you (mount point)
  - mount goliath:/progs /home/progs: mount nfs, pc name is goliath
  - umount /dev/fd0: umount it
 - parted - a partition manipulation program: create/move/increase/decrease partitions
  - usualy user to make place in HD for an OS or to copy HD-Data to a new HD
 - swapon, swapoff: see mkswap
 - sync [OPTION] [FILE]... - Synchronize cached writes to persistent storage
  
